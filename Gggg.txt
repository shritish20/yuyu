import os
import logging
import pandas as pd
import numpy as np
import httpx
import pickle
from io import BytesIO
from datetime import datetime, timedelta, date
from arch import arch_model
from scipy.stats import linregress
from fastapi import FastAPI, Depends, HTTPException, Query, Request, WebSocket, WebSocketDisconnect, Body, APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, ValidationError
from typing import List, Optional, Dict, Any, Set, Union

# --- ENVIRONMENT VARIABLES ---
# These environment variables must be set in your Render environment for the backend to function correctly.
# Example: SUPABASE_URL="https://your-project-id.supabase.co"
# Example: SUPABASE_KEY="your-supabase-anon-key"
# Example: UPSTOX_API_KEY="your_upstox_api_key"
# Example: UPSTOX_API_SECRET="your_upstox_api_secret"
# Example: UPSTOX_REDIRECT_URI="http://localhost:8000/auth/callback" # Or your Render callback URL

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
XG_BOOST_MODEL_URL = os.getenv("XG_BOOST_MODEL_URL", "https://raw.githubusercontent.com/shritish20/VolGuard-Pro/main/xgb_vol_model_v2.pkl")
NIFTY_HIST_URL = os.getenv("NIFTY_HIST_URL", "https://raw.githubusercontent.com/shritish20/VolGuard/main/nifty_50.csv")
IVP_HIST_URL = os.getenv("IVP_HIST_URL", "https://raw.githubusercontent.com/shritish20/VolGuard/main/ivp.csv")
UPCOMING_EVENTS_URL = os.getenv("UPCOMING_EVENTS_URL", "https://raw.githubusercontent.com/shritish20/VolGuard/main/upcoming_events.csv")
UPSTOX_API_KEY = os.getenv("UPSTOX_API_KEY")
UPSTOX_API_SECRET = os.getenv("UPSTOX_API_SECRET")
UPSTOX_REDIRECT_URI = os.getenv("UPSTOX_REDIRECT_URI")

# Ensure critical environment variables are set
if not SUPABASE_URL or not SUPABASE_KEY:
    raise ValueError("Supabase URL and Key must be set as environment variables.")
if not UPSTOX_API_KEY or not UPSTOX_API_SECRET or not UPSTOX_REDIRECT_URI:
    raise ValueError("Upstox API Key, API Secret, and Redirect URI must be set as environment variables.")

# --- LOGGING SETUP ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- SUPABASE CLIENT ---
SUPABASE_HEADERS = {
    "apikey": SUPABASE_KEY,
    "Content-Type": "application/json",
    "Prefer": "return=representation"
}

# In-memory store for access tokens (for demonstration/testing purposes,
# in a production environment, this should be a secure, persistent store like Redis or a database)
ACCESS_TOKEN_STORE: Dict[str, Any] = {"access_token": None, "expiry_time": None}

async def get_current_access_token() -> Optional[str]:
    """Retrieves the current valid access token from the store."""
    if ACCESS_TOKEN_STORE["access_token"] and ACCESS_TOKEN_STORE["expiry_time"] and \
       datetime.now() < ACCESS_TOKEN_STORE["expiry_time"]:
        return ACCESS_TOKEN_STORE["access_token"]
    return None

async def refresh_access_token(code: str) -> bool:
    """
    Exchanges authorization code for an access token and refreshes it.
    This is a simplified example; a full OAuth2 implementation would handle refresh tokens.
    """
    token_url = "https://api-v2.upstox.com/v2/login/authorization/token"
    payload = {
        "code": code,
        "client_id": UPSTOX_API_KEY,
        "client_secret": UPSTOX_API_SECRET,
        "redirect_uri": UPSTOX_REDIRECT_URI,
        "grant_type": "authorization_code"
    }
    headers = {
        "accept": "application/json",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(token_url, data=payload, headers=headers)
            response.raise_for_status()
            token_data = response.json()
            ACCESS_TOKEN_STORE["access_token"] = token_data.get("access_token")
            # Set expiry time based on expires_in (seconds), with a 5-minute buffer
            expires_in = token_data.get("expires_in", 3600)
            ACCESS_TOKEN_STORE["expiry_time"] = datetime.now() + timedelta(seconds=expires_in - 300)
            logger.info("Access token refreshed successfully.")
            return True
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error refreshing token: {e.response.status_code} - {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error refreshing token: {e}")
    return False

# Dependency to get access token for protected routes
async def get_upstox_access_token_dep() -> str:
    token = await get_current_access_token()
    if not token:
        raise HTTPException(status_code=401, detail="Upstox access token not available or expired. Please authorize.")
    return token

async def log_trade_to_supabase(data: Dict[str, Any]):
    """Logs a trade entry to Supabase, including fill status."""
    data["timestamp_entry"] = data.get("timestamp_entry", datetime.utcnow().isoformat() + "Z")
    data["timestamp_exit"] = data.get("timestamp_exit", datetime.utcnow().isoformat() + "Z")
    data["status"] = data.get("status", "closed") # Default to 'closed' if not specified
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(f"{SUPABASE_URL}/rest/v1/trade_logs", json=data, headers=SUPABASE_HEADERS)
            response.raise_for_status()
            logger.info(f"Trade logged to Supabase: {response.json()}")
            return response.status_code, response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error logging trade to Supabase: {e.response.status_code} - {e.response.text}")
        return e.response.status_code, {"error": e.response.text}
    except httpx.RequestError as e:
        logger.error(f"Network error logging trade to Supabase: {e}")
        return 500, {"error": str(e)}

async def add_journal_to_supabase(data: dict):
    """Adds a journal entry to Supabase."""
    data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(f"{SUPABASE_URL}/rest/v1/journals", json=data, headers={**SUPABASE_HEADERS, "Authorization": f"Bearer {SUPABASE_KEY}"})
            response.raise_for_status()
            logger.info(f"Journal entry added to Supabase: {response.json()}")
            return response.status_code, response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error adding journal to Supabase: {e.response.status_code} - {e.response.text}")
        return e.response.status_code, {"error": e.response.text}
    except httpx.RequestError as e:
        logger.error(f"Network error adding journal to Supabase: {e}")
        return 500, {"error": str(e)}

# --- FastAPI Setup ---
app = FastAPI(title="VoluGuard API", description="Comprehensive API for Volatility Analysis, Strategy Suggestion, Risk Management, and Trade Logging.")

# --- FastAPI Models ---
class TradeRequest(BaseModel):
    strategy: str
    instrument_token: str
    entry_price: float
    quantity: float
    realized_pnl: float
    unrealized_pnl: float
    regime_score: Optional[float] = None
    notes: Optional[str] = ""
    capital_used: Optional[float] = None
    potential_loss: Optional[float] = None
    sl_hit: Optional[bool] = False
    vega: Optional[float] = None
    timestamp_entry: Optional[str] = None
    timestamp_exit: Optional[str] = None
    status: Optional[str] = "closed" # Added status for clarity in logging

class JournalRequest(BaseModel):
    title: str
    content: str
    mood: str
    tags: Optional[str] = ""

class StrategyRequest(BaseModel):
    strategy: str
    lots: int = Field(1, ge=1)

class RiskEvaluationRequest(BaseModel):
    active_trades: List[TradeRequest]

# New Pydantic model for individual leg of a multi-leg order
class OrderLeg(BaseModel):
    strike: int
    option_type: str # "CE" or "PE"
    quantity: int
    transaction_type: str # "BUY" or "SELL"
    order_type: str # "MARKET" or "LIMIT"
    price: Optional[float] = None # Required if order_type is LIMIT

class PlaceOrderInput(BaseModel):
    index: str # "nifty" or "sensex"
    expiry: str # string (yyyy-mm-dd)
    gtt: Optional[bool] = False
    legs: List[OrderLeg] # List of order legs for multi-leg strategies

class ModifyOrderInput(BaseModel):
    order_id: str
    quantity: Optional[int] = None
    price: Optional[float] = None
    order_type: Optional[str] = None
    trigger_price: Optional[float] = None # For GTT or SL orders

class OrderStatusResponse(BaseModel):
    exchange_order_id: str
    tradingsymbol: Optional[str] = None
    instrument_token: str
    quantity: int
    price: float
    status: str
    average_price: Optional[float] = None
    transaction_type: Optional[str] = None
    product: Optional[str] = None
    order_type: Optional[str] = None
    validity: Optional[str] = None
    # Add other relevant fields from Upstox order details as needed for full tracking

class ModifyOrderResponse(BaseModel):
    status: str
    message: Optional[str] = None
    order_id: Optional[str] = None

class VolatilityPredictionInput(BaseModel):
    # These features are placeholders.
    # The actual features required for xgb_vol_model_v2.pkl
    # would need to be determined from the model's training data.
    # Examples might include: historical volatility, IV, VIX,
    # days to expiry, current market conditions, etc.
    feature1: float
    feature2: float
    feature3: float

# --- Helper Functions for Database (Supabase) ---
async def get_all_trades(status: Optional[str] = None):
    """Fetches all logged trade entries from Supabase, with optional status filter."""
    try:
        async with httpx.AsyncClient() as client:
            url = f"{SUPABASE_URL}/rest/v1/trade_logs"
            headers = {**SUPABASE_HEADERS, "Authorization": f"Bearer {SUPABASE_KEY}"}
            if status:
                url += f"?status=eq.{status}"
            response = await client.get(url, headers=headers)
            response.raise_for_status()
            logger.info("Successfully fetched trades from Supabase.")
            return response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching trades: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching trades: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching trades: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching trades: {str(e)}")

async def get_all_journals():
    """Fetches all logged journal entries from Supabase."""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{SUPABASE_URL}/rest/v1/journals", headers={**SUPABASE_HEADERS, "Authorization": f"Bearer {SUPABASE_KEY}"})
            response.raise_for_status()
            logger.info("Successfully fetched journals from Supabase.")
            return response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching journals: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching journals: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching journals: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching journals: {str(e)}")

# --- VolGuard Core Logic (Fully Merged from Original main.txt) ---

def get_financial_year(date_obj: datetime) -> str:
    """
    Returns capped Indian financial year in 'YYYY-YYYY' format.
    Caps to '2025-2026' if system date leads to '2025-2026'.
    """
    if date_obj.month >= 4:
        fy_start = date_obj.year
    else:
        fy_start = date_obj.year - 1

    fy_end = fy_start + 1

    # CAP to current allowed maximum year (Upstox limit)
    # This might need dynamic adjustment if Upstox changes its F&O expiry range
    if fy_start >= 2025: # Assuming 2025-2026 is the current limit
        return "2025-2026"

    return f"{fy_start}-{fy_end}"

# Global variable to store the XGBoost model
XGB_MODEL = None

async def load_xgboost_model():
    """Loads the XGBoost model from the specified URL."""
    global XGB_MODEL
    if XGB_MODEL is None:
        logger.info(f"Attempting to load XGBoost model from {XG_BOOST_MODEL_URL}")
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(XG_BOOST_MODEL_URL)
                response.raise_for_status()
                model_data = BytesIO(response.content)
                XGB_MODEL = pickle.load(model_data)
                logger.info("XGBoost model loaded successfully.")
        except httpx.HTTPStatusError as e:
            logger.error(f"Failed to fetch XGBoost model: HTTP error {e.response.status_code} - {e.response.text}")
            XGB_MODEL = None # Ensure model is None on failure
            raise HTTPException(status_code=500, detail=f"Failed to load XGBoost model: {e.response.text}")
        except Exception as e:
            logger.error(f"Error loading XGBoost model: {e}")
            XGB_MODEL = None # Ensure model is None on failure
            raise HTTPException(status_code=500, detail=f"Error loading XGBoost model: {e}")
    return XGB_MODEL

async def fetch_historical_data(url: str):
    """Fetches historical data (e.g., Nifty 50 or IVP) from a given URL."""
    logger.info(f"Fetching historical data from {url}...")
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url)
            response.raise_for_status()
            df = pd.read_csv(BytesIO(response.content), index_col='Date', parse_dates=True)
            logger.info(f"Historical data from {url} fetched successfully.")
            return df
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching historical data from {url}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=500, detail=f"Error fetching historical data: {e.response.text}")
    except Exception as e:
        logger.error(f"Error fetching or parsing historical data from {url}: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching or parsing historical data: {str(e)}")

async def calculate_volatility(config: Dict[str, Any], avg_iv: float):
    """
    Calculates volatility metrics: GARCH(1,1), IV-RV spread, IV Percentile, Realized Vol.
    Assumes `nifty_data` and `ivp_data` are available (fetched from URLs).
    """
    logger.info(f"Calculating volatility with avg_iv: {avg_iv}...")

    nifty_data = await fetch_historical_data(config["nifty_url"])
    ivp_data = await fetch_historical_data(config["ivp_url"])

    if nifty_data.empty or ivp_data.empty:
        raise HTTPException(status_code=500, detail="Failed to load historical data for volatility calculation.")

    # Convert 'Close' to numeric, handling potential non-numeric data
    nifty_data['Close'] = pd.to_numeric(nifty_data['Close'], errors='coerce')
    nifty_data.dropna(subset=['Close'], inplace=True)

    if nifty_data.empty or len(nifty_data) < 2:
        raise HTTPException(status_code=500, detail="Insufficient historical Nifty data for volatility calculation.")

    # Calculate daily returns
    nifty_data['Returns'] = np.log(nifty_data['Close'] / nifty_data['Close'].shift(1))
    nifty_data.dropna(inplace=True)

    if nifty_data.empty:
        raise HTTPException(status_code=500, detail="No valid returns for volatility calculation.")

    # Realized Volatility (7-day annualized)
    if len(nifty_data) >= 7:
        realized_vol_7_day = nifty_data['Returns'].rolling(window=7).std().iloc[-1] * np.sqrt(252) * 100
    else:
        realized_vol_7_day = 0.0

    # GARCH(1,1) Volatility (7-day forecast)
    try:
        if len(nifty_data) < 100: # Need sufficient data for robust GARCH
             logger.warning("Not enough data for robust GARCH model, using simpler estimate.")
             garch_forecast_7_day = avg_iv # Fallback to avg_iv if data insufficient
        else:
            model = arch_model(nifty_data['Returns'] * 100, vol='Garch', p=1, q=1)
            res = model.fit(disp='off')
            forecast = res.forecast(horizon=7)
            garch_variance = forecast.variance.iloc[-1]
            garch_forecast_7_day = np.sqrt(garch_variance).mean() * np.sqrt(252)
    except Exception as e:
        logger.error(f"Error in GARCH model: {e}. Falling back to avg_iv.")
        garch_forecast_7_day = avg_iv

    # IV-RV Spread
    iv_rv_spread = avg_iv - realized_vol_7_day

    # IV Percentile
    ivp_data['IV'] = pd.to_numeric(ivp_data['IV'], errors='coerce')
    ivp_data.dropna(subset=['IV'], inplace=True)

    if ivp_data.empty:
        iv_percentile = 0.5 # Default if no IVP data
    else:
        iv_percentile = (avg_iv > ivp_data['IV']).mean()

    return realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile


async def get_market_metrics_data(index: str):
    """
    Fetches market metrics data.
    NOTE: Real-time Open Interest (OI) for accurate PCR and Max Pain calculation is NOT
    available via Upstox's public REST API (as per provided openapi.txt), only historical.
    To implement live PCR/Max Pain, a dedicated real-time WebSocket connection to all
    option instruments would be required to aggregate OI data on the server side.
    Therefore, Max Pain and PCR will be returned as None.
    Days to Expiry is calculated from dynamic expiry.
    """
    logger.info("Fetching market metrics data...")
    
    # Get current expiry for 'days_to_expiry'
    # Need access token here if not coming from a dependency
    expiries_data = await get_expiries_endpoint(index=index, access_token=await get_upstox_access_token_dep())
    current_expiry_str = expiries_data.get("current_expiry")
    
    days_to_expiry = 0
    if current_expiry_str:
        current_expiry_date = datetime.strptime(current_expiry_str, "%Y-%m-%d").date()
        days_to_expiry = (current_expiry_date - date.today()).days
        if days_to_expiry < 0:
            days_to_expiry = 0

    # Max Pain and PCR cannot be accurately calculated without real-time Open Interest data.
    # Upstox's provided OpenAPI only lists historical OI.
    # Therefore, returning None for these metrics.
    pcr = None
    max_pain = None

    return {
        "pcr": pcr,
        "max_pain": max_pain,
        "days_to_expiry": days_to_expiry
    }

async def calculate_regime_score(access_token: str, index: str):
    """
    Calculates a multi-factor regime score.
    """
    logger.info("Calculating regime score...")

    try:
        nifty_spot_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}{' 50' if index.lower() == 'nifty' else ''}"
        spot_price = await get_spot_price_from_upstox(nifty_spot_key, access_token)
        if spot_price is None:
            raise ValueError(f"Could not fetch spot price for {index} to calculate regime score.")
        
        # Approximate average IV from ATM option.
        expiries_data = await get_expiries_endpoint(index=index, access_token=access_token)
        current_expiry_str = expiries_data.get("current_expiry")
        if not current_expiry_str:
            raise ValueError(f"Could not determine current expiry for {index} for regime score.")
        
        option_chain = await get_option_chain_from_upstox(index, current_expiry_str, access_token)
        atm_strike = int(round(spot_price / 100) * 100)
        atm_ce_greeks = None
        if atm_strike in option_chain and option_chain[atm_strike]["CE"]:
            atm_ce_greeks = await get_option_greeks_from_upstox(option_chain[atm_strike]["CE"]["instrument_token"], access_token)
        
        avg_iv = atm_ce_greeks.get("iv", 0.0) if atm_ce_greeks else 0.0

        config = await get_config(access_token)
        realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile = await calculate_volatility(config, avg_iv)

        # Additional factors (placeholders, these would need more data/logic)
        trend_strength = 0.6
        sentiment_score = 0.8
        
        # Simple weighted average for regime score, normalized.
        regime_score = (
            (realized_vol_7_day / 50.0) * 0.2 + # Normalize RV (assuming max 50%)
            (garch_forecast_7_day / 50.0) * 0.2 + # Normalize GARCH
            (iv_percentile) * 0.2 + # IVP is already 0-1
            trend_strength * 0.2 +
            sentiment_score * 0.2
        )
        regime_score = min(1.0, max(0.0, regime_score)) # Cap between 0 and 1

        return regime_score
    except Exception as e:
        logger.error(f"Error calculating regime score: {e}")
        return 0.5 # Default/neutral score on error

async def evaluate_risk(active_trades: List[TradeRequest]):
    """
    Performs position-level, portfolio-level checks, and behavioral rules.
    This module uses the provided active_trades for evaluation.
    """
    logger.info(f"Evaluating risk for {len(active_trades)} trades...")
    
    total_unrealized_pnl = sum(trade.unrealized_pnl for trade in active_trades)
    total_capital_deployed = sum(trade.capital_used for trade in active_trades if trade.capital_used is not None)
    
    # Dummy config for risk limits (in a real app, fetch from user settings or config)
    mock_total_funds = 2000000
    daily_risk_limit = mock_total_funds * 0.02

    exceeds_daily_limit = False
    if total_unrealized_pnl < 0 and abs(total_unrealized_pnl) > daily_risk_limit:
        exceeds_daily_limit = True

    overall_risk = "low"
    if exceeds_daily_limit:
        overall_risk = "high"
    elif total_capital_deployed > mock_total_funds * 0.5:
        overall_risk = "medium"

    return {
        "overall_risk": overall_risk,
        "exceeds_daily_limit": exceeds_daily_limit,
        "total_unrealized_pnl": total_unrealized_pnl,
        "total_capital_deployed": total_capital_deployed
    }

async def suggest_strategy(iv_percentile: float, regime_score: float, days_to_expiry: int):
    """
    Suggests options strategies based on IV Percentile, Regime Score, and Days to Expiry.
    This implements the core VolGuard strategy suggestion logic.
    """
    logger.info(f"Suggesting strategy for IVP: {iv_percentile}, Regime Score: {regime_score}, DTE: {days_to_expiry}...")

    suggestions = []

    # Strategy based on IV Percentile
    if iv_percentile >= 0.70: # High IVP: Sell premium
        suggestions.append("Iron Condor (High IVP)")
        suggestions.append("Short Straddle/Strangle (High IVP)")
        suggestions.append("Jade Lizard (High IVP, bullish bias)")
    elif iv_percentile <= 0.30: # Low IVP: Buy premium
        suggestions.append("Long Straddle/Strangle (Low IVP)")
        suggestions.append("Calendar Spread (Low IVP, time decay)")
        suggestions.append("Bull/Bear Spreads (Low IVP, directional)")
    else: # Medium IVP
        suggestions.append("Iron Fly (Medium IVP, neutral)")
        suggestions.append("Credit Spreads (Medium IVP, directional bias)")

    # Adjust based on Regime Classification
    if regime_score >= 0.7: # Bullish/Strong Up-trend
        if "Iron Condor (High IVP)" in suggestions:
            suggestions.remove("Iron Condor (High IVP)")
        if "Short Straddle/Strangle (High IVP)" in suggestions:
            suggestions.remove("Short Straddle/Strangle (High IVP)")
        suggestions.append("Bull Call Spread (Strong Bullish)")
        suggestions.append("Short Put (Strong Bullish)")
    elif regime_score <= 0.3: # Bearish/Strong Down-trend
        if "Iron Condor (High IVP)" in suggestions:
            suggestions.remove("Iron Condor (High IVP)")
        if "Short Straddle/Strangle (High IVP)" in suggestions:
            suggestions.remove("Short Straddle/Strangle (High IVP)")
        suggestions.append("Bear Put Spread (Strong Bearish)")
        suggestions.append("Short Call (Strong Bearish)")

    # Adjust based on Days to Expiry
    if days_to_expiry < 7: # Short-term expiry (more theta decay)
        if "Iron Condor (High IVP)" in suggestions:
            pass
        elif "Iron Condor (High IVP)" not in suggestions and iv_percentile >= 0.70:
            suggestions.append("Iron Condor (Short DTE, High IVP)")
        if "Short Straddle/Strangle (High IVP)" in suggestions:
            pass
        elif "Short Straddle/Strangle (High IVP)" not in suggestions and iv_percentile >= 0.70:
            suggestions.append("Short Straddle/Strangle (Short DTE, High IVP)")
        
        for s in ["Calendar Spread (Low IVP, time decay)", "Long Straddle/Strangle (Low IVP)"]:
            if s in suggestions: suggestions.remove(s)

    elif days_to_expiry > 30: # Long-term expiry (less theta decay, more vega sensitivity)
        if iv_percentile <= 0.30 and "Long Straddle/Strangle (Low IVP)" not in suggestions:
            suggestions.append("Long Straddle/Strangle (Long DTE, Low IVP)")
        if "Calendar Spread (Low IVP, time decay)" not in suggestions:
             suggestions.append("Calendar Spread (Long DTE, Low IVP)")

    return list(set(suggestions))

# --- CONFIGURATION & UPSTOX API SETUP ---
def get_upstox_headers(access_token: str) -> Dict[str, str]:
    """
    Returns standard headers for Upstox API calls, including Authorization.
    """
    return {
        "accept": "application/json",
        "Api-Version": "2.0",
        "Authorization": f"Bearer {access_token}"
    }

async def get_config(access_token: str) -> Dict[str, Any]:
    """
    Retrieves dynamic configuration, including Upstox API headers and general settings.
    """
    upstox_headers = get_upstox_headers(access_token)
    config = {
        "base_url": "https://api.upstox.com/v2",
        "v3_url": "https://api-v2.upstox.com/v3",
        "headers": upstox_headers,
        "nifty_url": NIFTY_HIST_URL,
        "ivp_url": IVP_HIST_URL,
        "event_url": UPCOMING_EVENTS_URL,
        "total_funds": 2000000,
        "risk_config": {
            "Iron Fly": {"capital_pct": 0.30, "risk_per_trade_pct": 0.01},
            "Iron Condor": {"capital_pct": 0.25, "risk_per_trade_pct": 0.015},
            "Jade Lizard": {"capital_pct": 0.20, "risk_per_trade_pct": 0.01},
            "Straddle": {"capital_pct": 0.15, "risk_per_trade_pct": 0.02},
            "Calendar Spread": {"capital_pct": 0.10, "risk_per_trade_pct": 0.01},
            "Bull Put Spread": {"capital_pct": 0.15, "risk_per_trade_pct": 0.01},
            "Wide Strangle": {"capital_pct": 0.10, "risk_per_trade_pct": 0.015},
            "ATM Strangle": {"capital_pct": 0.10, "risk_per_trade_pct": 0.015}
        },
        "daily_risk_limit_pct": 0.02,
        "weekly_risk_limit_pct": 0.03,
        "lot_size": 50 # Nifty lot size
    }
    try:
        async with httpx.AsyncClient() as client:
            funds_resp = await client.get(f"{config['base_url']}/user/get-funds-and-margin", headers=config['headers'])
            funds_resp.raise_for_status()
            funds = funds_resp.json()["data"]["equity"]
            config["available_margin"] = float(funds["available_margin"] or 0)
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching funds: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching funds: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching funds: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching funds: {str(e)}")
    return config

# Helper to map index to instrument key prefix
INDEX_TO_INSTRUMENT_PREFIX = {
    "nifty": "NSE_INDEX",
    "sensex": "BSE_INDEX"
}

INDEX_TO_CONTRACT_SYMBOL = {
    "nifty": "NIFTY",
    "sensex": "SENSEX"
}

async def get_expiries_from_upstox(index: str, access_token: str) -> List[str]:
    """
    Fetches all available expiry dates for a given index from Upstox.
    Uses /option/contract to pull all expiries.
    """
    base_instrument_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}"
    if index.lower() == "nifty":
        base_instrument_key += " 50"

    url = "https://api-v2.upstox.com/v2/option/contract"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": base_instrument_key}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()["data"]
            all_expiries = sorted(list(set(item["expiry"] for item in data)))
            return all_expiries
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching expiries for {index}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching expiries: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching expiries for {index}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching expiries: {str(e)}")

async def get_option_chain_from_upstox(index: str, expiry: str, access_token: str) -> Dict[str, Any]:
    """
    Fetches the full option chain for a given index and expiry from Upstox.
    Groups by strike and option type (CE/PE).
    """
    instrument_key_prefix = INDEX_TO_INSTRUMENT_PREFIX[index.lower()]
    contract_symbol = INDEX_TO_CONTRACT_SYMBOL[index.lower()]
    
    base_instrument_key_filter = f"{instrument_key_prefix}|{contract_symbol}"
    if index.lower() == "nifty":
        base_instrument_key_filter += " 50"

    url = "https://api-v2.upstox.com/v2/option/contract"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": base_instrument_key_filter}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            all_contracts = response.json()["data"]

            option_chain = {}
            for contract in all_contracts:
                if contract["expiry"] == expiry:
                    strike_price = int(contract["strike_price"])
                    option_type = contract["option_type"]
                    instrument_token = contract["instrument_key"]

                    if strike_price not in option_chain:
                        option_chain[strike_price] = {"CE": None, "PE": None}
                    
                    option_chain[strike_price][option_type] = {
                        "instrument_token": instrument_token,
                        "strike_price": strike_price,
                        "option_type": option_type,
                        "expiry": expiry
                    }
            return option_chain
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching option chain for {index} expiry {expiry}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching option chain: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching option chain for {index} expiry {expiry}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching option chain: {str(e)}")

async def get_instrument_token(index: str, strike: int, expiry: str, option_type: str, access_token: str) -> Optional[str]:
    """
    Resolves instrument token for a given option contract using the option chain.
    """
    option_chain = await get_option_chain_from_upstox(index, expiry, access_token)
    if strike in option_chain and option_chain[strike][option_type]:
        return option_chain[strike][option_type]["instrument_token"]
    return None

async def get_spot_price_from_upstox(instrument_key: str, access_token: str) -> Optional[float]:
    """
    Gets the real-time Last Traded Price (LTP) for a given instrument key.
    """
    url = "https://api-v2.upstox.com/v2/market-quote/ltp"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": instrument_key}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()["data"]
            if instrument_key in data and data[instrument_key]:
                return data[instrument_key].get("ltp")
            return None
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching LTP for {instrument_key}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching LTP: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching LTP for {instrument_key}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching LTP: {str(e)}")

async def get_option_greeks_from_upstox(instrument_key: str, access_token: str) -> Optional[Dict[str, Any]]:
    """
    Gets option Greeks (IV, delta, theta, vega, gamma) for a given instrument key.
    """
    url = "https://api-v2.upstox.com/v2/market-quote/option-greek"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": instrument_key}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()["data"]
            if instrument_key in data and data[instrument_key]:
                return data[instrument_key]
            return None
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching option Greeks for {instrument_key}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching option Greeks: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching option Greeks for {instrument_key}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching option Greeks: {str(e)}")

async def get_market_timings_from_upstox(exchange: Optional[str] = None, product_type: Optional[str] = None, access_token: str) -> Dict[str, Any]:
    """
    Gets market timings and holiday information from Upstox.
    """
    url = "https://api-v2.upstox.com/v2/market/timings"
    headers = get_upstox_headers(access_token)
    params = {}
    if exchange:
        params["exchange"] = exchange
    if product_type:
        params["product_type"] = product_type

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()["data"]
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching market timings: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching market timings: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching market timings: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching market timings: {str(e)}")

# --- FastAPI Endpoints ---

@app.on_event("startup")
async def startup_event():
    """Load XGBoost model on application startup."""
    await load_xgboost_model()

@app.get("/auth/login")
async def login():
    """
    Initiates the Upstox OAuth2 login process.
    Redirects to Upstox authorization URL.
    """
    auth_url = "https://api-v2.upstox.com/v2/login/authorization/dialog"
    params = {
        "response_type": "code",
        "client_id": UPSTOX_API_KEY,
        "redirect_uri": UPSTOX_REDIRECT_URI
    }
    query_string = "&".join([f"{k}={v}" for k, v in params.items()])
    full_auth_url = f"{auth_url}?{query_string}"
    return JSONResponse(content={"authorization_url": full_auth_url})

@app.get("/auth/callback")
async def auth_callback(code: str = Query(..., description="Authorization code from Upstox")):
    """
    Callback endpoint for Upstox OAuth2. Exchanges the authorization code for an access token.
    """
    if await refresh_access_token(code):
        return {"message": "Authentication successful! Access token obtained."}
    raise HTTPException(status_code=400, detail="Failed to obtain access token.")


@app.post("/log-trade", response_model=Dict[str, Any])
async def log_trade(trade: TradeRequest):
    """Logs a trade entry to Supabase."""
    status_code, response_data = await log_trade_to_supabase(trade.dict())
    if status_code in [200, 201]:
        return {"message": "Trade logged successfully", "data": response_data}
    raise HTTPException(status_code=status_code, detail=response_data.get("error", "Failed to log trade."))

@app.get("/get-trades", response_model=Dict[str, List[Dict[str, Any]]])
async def get_trades(status: Optional[str] = Query(None)):
    """Fetches all logged trade entries from Supabase, with optional status filter."""
    trades = await get_all_trades(status)
    return {"trades": trades}

@app.post("/add-journal", response_model=Dict[str, Any])
async def add_journal(journal: JournalRequest):
    """Adds a journal entry to Supabase."""
    status_code, response_data = await add_journal_to_supabase(journal.dict())
    if status_code in [200, 201]:
        return {"message": "Journal entry added successfully", "data": response_data}
    raise HTTPException(status_code=status_code, detail=response_data.get("error", "Failed to add journal entry."))

@app.get("/get-journals", response_model=Dict[str, List[Dict[str, Any]]])
async def get_journals():
    """Fetches all logged journal entries from Supabase."""
    journals = await get_all_journals()
    return {"journals": journals}

@app.get("/expiries", response_model=Dict[str, Optional[str]])
async def get_expiries_endpoint(index: str = Query(..., description="Index name, e.g., NIFTY or SENSEX"),
                                access_token: str = Depends(get_upstox_access_token_dep)):
    """
    Retrieves current, next weekly, and next monthly expiry dates for Nifty or Sensex.
    Automatically detects holidays or special expiry shifts.
    """
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")

    all_expiries = await get_expiries_from_upstox(index, access_token)
    
    today = date.today()
    current_expiry = None
    next_weekly_expiry = None
    next_monthly_expiry = None

    future_expiries_dt = sorted([datetime.strptime(e, "%Y-%m-%d").date() for e in all_expiries if datetime.strptime(e, "%Y-%m-%d").date() >= today])

    if not future_expiries_dt:
        raise HTTPException(status_code=404, detail="No upcoming expiries found.")

    current_expiry = future_expiries_dt[0].strftime("%Y-%m-%d")

    weekly_expiries = sorted([e for e in future_expiries_dt if e.weekday() == 3])
    
    monthly_expiries = []
    seen_months_years = set()
    for exp_date in future_expiries_dt:
        if exp_date.weekday() == 3:
            if (exp_date + timedelta(days=7)).month != exp_date.month:
                month_year = (exp_date.year, exp_date.month)
                if month_year not in seen_months_years:
                    monthly_expiries.append(exp_date)
                    seen_months_years.add(month_year)
    monthly_expiries = sorted(monthly_expiries)

    for exp in weekly_expiries:
        if exp > datetime.strptime(current_expiry, "%Y-%m-%d").date():
            next_weekly_expiry = exp.strftime("%Y-%m-%d")
            break
    
    for exp in monthly_expiries:
        if exp > datetime.strptime(current_expiry, "%Y-%m-%d").date():
            next_monthly_expiry = exp.strftime("%Y-%m-%d")
            break
    
    return {
        "current_expiry": current_expiry,
        "next_weekly_expiry": next_weekly_expiry,
        "next_monthly_expiry": next_monthly_expiry
    }


@app.get("/option-chain", response_model=Dict[str, Dict[str, Dict[str, Any]]])
async def get_option_chain_endpoint(
    index: str = Query(..., description="Index name, e.g., NIFTY or SENSEX"),
    expiry: str = Query(..., description="Expiry date in YYYY-MM-DD format"),
    access_token: str = Depends(get_upstox_access_token_dep)
):
    """
    Retrieves the full option chain for a specified index and expiry.
    """
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")
    
    try:
        datetime.strptime(expiry, "%Y-%m-%d")
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid expiry date format. Use YYYY-MM-DD.")

    option_chain_data = await get_option_chain_from_upstox(index, expiry, access_token)
    if not option_chain_data:
        raise HTTPException(status_code=404, detail=f"No option chain found for {index} with expiry {expiry}.")
    return option_chain_data

@app.post("/place-order", response_model=Dict[str, Any])
async def place_order_endpoint(
    order_input: PlaceOrderInput,
    access_token: str = Depends(get_upstox_access_token_dep)
):
    """
    Places regular or GTT orders for multi-leg strategies on Upstox.
    After placing, it attempts to check and log the fill status for each leg.
    """
    headers = get_upstox_headers(access_token)
    headers["Api-Version"] = "3.0" # Use API-Version 3.0 for order placement

    placed_orders_info = []
    order_type_str = "REGULAR"

    for leg_idx, leg in enumerate(order_input.legs):
        instrument_token = await get_instrument_token(
            order_input.index, leg.strike, order_input.expiry, leg.option_type, access_token
        )
        if not instrument_token:
            logger.error(f"Could not resolve instrument token for leg {leg_idx}: {order_input.index} {leg.strike} {leg.option_type} on {order_input.expiry}")
            placed_orders_info.append({"status": "failed", "message": f"Instrument token not found for leg {leg_idx}", "leg": leg.dict()})
            continue

        order_payload = {
            "quantity": leg.quantity,
            "instrument_token": instrument_token,
            "product": "D", # Assuming 'D' for Delivery/Derivatives for options
            "transaction_type": leg.transaction_type,
            "order_type": leg.order_type,
        }

        if leg.order_type == "LIMIT":
            if leg.price is None:
                logger.error(f"Price is required for LIMIT order in leg {leg_idx}.")
                placed_orders_info.append({"status": "failed", "message": f"Price missing for LIMIT order in leg {leg_idx}", "leg": leg.dict()})
                continue
            order_payload["price"] = leg.price
        elif leg.price is not None and leg.order_type == "MARKET":
            logger.warning(f"Price provided for MARKET order in leg {leg_idx}: {leg.strike} {leg.option_type}. Price will be ignored by Upstox.")

        if order_input.gtt:
            gtt_url = "https://api-v2.upstox.com/v3/order/gtt/place"
            if leg.order_type == "MARKET":
                logger.error(f"GTT orders cannot be MARKET orders for leg {leg_idx}.")
                placed_orders_info.append({"status": "failed", "message": f"GTT orders cannot be MARKET orders for leg {leg_idx}", "leg": leg.dict()})
                continue
            if leg.price is None:
                logger.error(f"Price is required for GTT LIMIT order in leg {leg_idx}.")
                placed_orders_info.append({"status": "failed", "message": f"Price missing for GTT LIMIT order in leg {leg_idx}", "leg": leg.dict()})
                continue
            
            # Simplified GTT rule: single trigger at the provided price
            gtt_order_payload = {
                "instrument_token": order_payload["instrument_token"],
                "quantity": order_payload["quantity"],
                "product": order_payload["product"],
                "transaction_type": order_payload["transaction_type"],
                "order_type": order_payload["order_type"],
                "price": order_payload["price"],
                "rules": [
                    {
                        "strategy": "ENTRY",
                        "trigger_type": "ABOVE" if order_payload["transaction_type"] == "BUY" else "BELOW",
                        "trigger_price": order_payload["price"] # Using price as trigger for simplicity
                    }
                ],
                "type": "SINGLE"
            }
            order_type_str = "GTT"
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.post(gtt_url, json=gtt_order_payload, headers=headers)
                    response.raise_for_status()
                    response_data = response.json()
                    order_id = response_data.get("data", {}).get("order_id")
                    placed_orders_info.append({
                        "status": "success",
                        "order_id": order_id,
                        "leg": leg.dict(),
                        "raw_response": response_data
                    })
                    logger.info(f"GTT order placed for leg {leg_idx}: {order_id}")
            except httpx.HTTPStatusError as e:
                logger.error(f"HTTP error placing GTT order for leg {leg_idx} ({leg.strike} {leg.option_type}): {e.response.status_code} - {e.response.text}")
                placed_orders_info.append({
                    "status": "failed",
                    "message": f"HTTP error: {e.response.text}",
                    "leg": leg.dict(),
                    "status_code": e.response.status_code
                })
            except httpx.RequestError as e:
                logger.error(f"Network error placing GTT order for leg {leg_idx} ({leg.strike} {leg.option_type}): {e}")
                placed_orders_info.append({
                    "status": "failed",
                    "message": f"Network error: {str(e)}",
                    "leg": leg.dict()
                })
        else: # Regular order
            regular_order_url = "https://api-v2.upstox.com/v3/order/place"
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.post(regular_order_url, json=order_payload, headers=headers)
                    response.raise_for_status()
                    response_data = response.json()
                    order_id = response_data.get("data", {}).get("order_id")
                    placed_orders_info.append({
                        "status": "success",
                        "order_id": order_id,
                        "leg": leg.dict(),
                        "raw_response": response_data
                    })
                    logger.info(f"Regular order placed for leg {leg_idx}: {order_id}")
            except httpx.HTTPStatusError as e:
                logger.error(f"HTTP error placing regular order for leg {leg_idx} ({leg.strike} {leg.option_type}): {e.response.status_code} - {e.response.text}")
                placed_orders_info.append({
                    "status": "failed",
                    "message": f"HTTP error: {e.response.text}",
                    "leg": leg.dict(),
                    "status_code": e.response.status_code
                })
            except httpx.RequestError as e:
                logger.error(f"Network error placing regular order for leg {leg_idx} ({leg.strike} {leg.option_type}): {e}")
                placed_orders_info.append({
                    "status": "failed",
                    "message": f"Network error: {str(e)}",
                    "leg": leg.dict()
                })
    
    # --- Trade Fill Confirmation and Logging ---
    # This section demonstrates how to check order status and log to Supabase.
    # In a true real-time system, this would often be asynchronous polling or
    # triggered by WebSocket events, not blocking the /place-order response.
    # For a synchronous API call, this is a conceptual example of next steps.
    final_trade_logs = []
    for order_info in placed_orders_info:
        if order_info["status"] == "success" and order_info["order_id"]:
            order_id = order_info["order_id"]
            leg_details = order_info["leg"]
            try:
                # Fetch final status of the order (this is a direct call for demonstration)
                order_status_response = await get_order_status_endpoint(order_id=order_id, access_token=access_token)
                
                # Prepare data for Supabase logging
                trade_data_to_log = {
                    "strategy": "Multi-leg Order", # Or infer from request
                    "instrument_token": order_status_response.instrument_token,
                    "entry_price": order_status_response.average_price or order_status_response.price,
                    "quantity": order_status_response.quantity,
                    "realized_pnl": 0.0, # Will be calculated later upon exit
                    "unrealized_pnl": 0.0, # Will be calculated later
                    "notes": f"Multi-leg order leg: {leg_details['strike']} {leg_details['option_type']}",
                    "status": order_status_response.status.lower(), # E.g., 'complete', 'open', 'rejected'
                    "exchange_order_id": order_status_response.exchange_order_id,
                    "transaction_type": order_status_response.transaction_type,
                    "product": order_status_response.product,
                    "order_type": order_status_response.order_type,
                    "timestamp_entry": datetime.utcnow().isoformat() + "Z" # Assuming entry at placement
                }
                
                log_status_code, log_response = await log_trade_to_supabase(trade_data_to_log)
                final_trade_logs.append({
                    "order_id": order_id,
                    "status": order_status_response.status,
                    "log_status": "success" if log_status_code in [200, 201] else "failed",
                    "logged_data": trade_data_to_log
                })
            except HTTPException as e:
                logger.error(f"Failed to get order status or log trade for {order_id}: {e.detail}")
                final_trade_logs.append({
                    "order_id": order_id,
                    "status": "error_fetching_status",
                    "log_status": "failed",
                    "error_detail": e.detail
                })
        else:
            final_trade_logs.append(order_info) # Include failed order placements as well

    overall_status = "success" if all(info["status"] == "success" for info in placed_orders_info) else "partial_success" if any(info["status"] == "success" for info in placed_orders_info) else "failed"

    return {
        "status": overall_status,
        "message": f"{overall_status.replace('_', ' ').capitalize()} for multi-leg order. Check 'details' for each leg.",
        "type": order_type_str,
        "details": placed_orders_info,
        "trade_logging_results": final_trade_logs
    }


@app.get("/ltp", response_model=Dict[str, Any])
async def get_ltp_endpoint(instrument_key: str = Query(..., description="Instrument key (e.g., NSE_FO|NIFTY|2025-07-31|19500CE)"),
                           access_token: str = Depends(get_upstox_access_token_dep)):
    """
    Gets the real-time Last Traded Price (LTP) for a given instrument.
    """
    ltp = await get_spot_price_from_upstox(instrument_key, access_token)
    if ltp is None:
        raise HTTPException(status_code=404, detail=f"LTP not found for instrument key: {instrument_key}")
    return {"instrument_key": instrument_key, "ltp": ltp}

@app.get("/option-greeks", response_model=Dict[str, Any])
async def get_option_greeks_endpoint(instrument_key: str = Query(..., description="Instrument key (e.g., NSE_FO|NIFTY|2025-07-31|19500CE)"),
                                     access_token: str = Depends(get_upstox_access_token_dep)):
    """
    Gets option Greeks (IV, delta, theta, vega, gamma) for a given instrument key.
    """
    greeks = await get_option_greeks_from_upstox(instrument_key, access_token)
    if greeks is None:
        raise HTTPException(status_code=404, detail=f"Option Greeks not found for instrument key: {instrument_key}")
    return greeks

@app.get("/market-timings", response_model=Dict[str, Any])
async def get_market_timings_endpoint(exchange: Optional[str] = Query(None, description="Exchange, e.g., NSE"),
                                     product_type: Optional[str] = Query(None, description="Product type, e.g., EQUITY, FUTURE, OPTION"),
                                     access_token: str = Depends(get_upstox_access_token_dep)):
    """
    Gets market timings and holiday information.
    """
    timings = await get_market_timings_from_upstox(exchange, product_type, access_token)
    if not timings:
        raise HTTPException(status_code=404, detail="Market timings not found.")
    return timings

@app.get("/order-status", response_model=OrderStatusResponse)
async def get_order_status_endpoint(
    order_id: str = Query(..., description="The ID of the order to check status for."),
    access_token: str = Depends(get_upstox_access_token_dep)
):
    """
    Fetches the current status of a specific order from Upstox.
    """
    url = "https://api-v2.upstox.com/v2/order/details"
    headers = get_upstox_headers(access_token)
    params = {"order_id": order_id}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            order_details = response.json()["data"]
            if not order_details:
                raise HTTPException(status_code=404, detail=f"Order with ID {order_id} not found.")
            # Map Upstox response to OrderStatusResponse Pydantic model
            return OrderStatusResponse(
                exchange_order_id=order_details.get("exchange_order_id", order_id),
                tradingsymbol=order_details.get("tradingsymbol"),
                instrument_token=order_details.get("instrument_token"),
                quantity=order_details.get("quantity"),
                price=order_details.get("price"),
                status=order_details.get("status"),
                average_price=order_details.get("average_price"),
                transaction_type=order_details.get("transaction_type"),
                product=order_details.get("product"),
                order_type=order_details.get("order_type"),
                validity=order_details.get("validity")
            )
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching order status for {order_id}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching order status: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching order status for {order_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching order status: {str(e)}")

@app.put("/modify-order", response_model=ModifyOrderResponse)
async def modify_order_endpoint(
    modify_input: ModifyOrderInput,
    access_token: str = Depends(get_upstox_access_token_dep)
):
    """
    Modifies an existing order (regular or GTT) on Upstox.
    """
    headers = get_upstox_headers(access_token)
    headers["Api-Version"] = "3.0"

    is_gtt_modify = modify_input.trigger_price is not None

    if is_gtt_modify:
        url = "https://api-v2.upstox.com/v3/order/gtt/modify"
        # GTT modify requires the original gtt_order_id and rules
        # For simplicity, assuming 'ENTRY' strategy and re-providing a single rule.
        # In a real scenario, you'd fetch the existing GTT rule or have its type stored.
        payload = {
            "gtt_order_id": modify_input.order_id,
            "rules": [
                {
                    "strategy": "ENTRY",
                    "trigger_type": "ABOVE", # This needs to be dynamically determined from original GTT order or inferred
                    "trigger_price": modify_input.trigger_price
                }
            ],
            "type": "SINGLE"
        }
        if modify_input.quantity is not None:
            payload["quantity"] = modify_input.quantity
        if modify_input.price is not None:
            payload["price"] = modify_input.price
    else:
        url = "https://api-v2.upstox.com/v3/order/modify"
        payload = {
            "order_id": modify_input.order_id,
            "quantity": modify_input.quantity,
            "price": modify_input.price,
            "order_type": modify_input.order_type
        }
        payload = {k: v for k, v in payload.items() if v is not None}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.put(url, json=payload, headers=headers)
            response.raise_for_status()
            return response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error modifying order {modify_input.order_id}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error modifying order: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error modifying order {modify_input.order_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error modifying order: {str(e)}")

# --- VolGuard Specific Endpoints (Fully functional with Upstox integration) ---

@app.get("/volguard/dashboard", response_model=Dict[str, Any])
async def get_volguard_dashboard(index: str = Query("NIFTY", description="Index for dashboard: NIFTY or SENSEX"),
                                access_token: str = Depends(get_upstox_access_token_dep)):
    """
    Endpoint to provide a comprehensive VolGuard dashboard with combined metrics.
    Integrates data from Upstox (spot price, Greeks) with VolGuard's internal calculations.
    NOTE: Real-time Open Interest data for PCR and Max Pain is not available via Upstox REST API.
    """
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")

    config = await get_config(access_token)
    
    nifty_spot_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}{' 50' if index.lower() == 'nifty' else ''}"
    spot_price = await get_spot_price_from_upstox(nifty_spot_key, access_token)
    if spot_price is None:
        raise HTTPException(status_code=404, detail=f"Could not fetch spot price for {index}.")

    expiries_data = await get_expiries_endpoint(index=index, access_token=access_token)
    current_expiry_str = expiries_data.get("current_expiry")
    if not current_expiry_str:
        raise HTTPException(status_code=404, detail=f"Could not determine current expiry for {index}.")

    option_chain = await get_option_chain_from_upstox(index, current_expiry_str, access_token)
    
    atm_strike = int(round(spot_price / 100) * 100)
    
    atm_ce_greeks = None
    atm_pe_greeks = None

    if atm_strike in option_chain:
        if option_chain[atm_strike]["CE"]:
            atm_ce_greeks = await get_option_greeks_from_upstox(option_chain[atm_strike]["CE"]["instrument_token"], access_token)
        if option_chain[atm_strike]["PE"]:
            atm_pe_greeks = await get_option_greeks_from_upstox(option_chain[atm_strike]["PE"]["instrument_token"], access_token)
    
    avg_iv = 0.0
    theta_sum = 0.0
    vega_sum = 0.0
    delta_sum = 0.0
    gamma_sum = 0.0
    count_greeks = 0

    if atm_ce_greeks and atm_ce_greeks.get("iv"):
        avg_iv += atm_ce_greeks["iv"]
        theta_sum += atm_ce_greeks.get("theta", 0.0)
        vega_sum += atm_ce_greeks.get("vega", 0.0)
        delta_sum += atm_ce_greeks.get("delta", 0.0)
        gamma_sum += atm_ce_greeks.get("gamma", 0.0)
        count_greeks += 1
    if atm_pe_greeks and atm_pe_greeks.get("iv"):
        avg_iv += atm_pe_greeks["iv"]
        theta_sum += atm_pe_greeks.get("theta", 0.0)
        vega_sum += atm_pe_greeks.get("vega", 0.0)
        delta_sum += atm_pe_greeks.get("delta", 0.0)
        gamma_sum += atm_pe_greeks.get("gamma", 0.0)
        count_greeks += 1
    
    if count_greeks > 0:
        avg_iv /= count_greeks
        theta_avg = theta_sum / count_greeks
        vega_avg = vega_sum / count_greeks
        delta_avg = delta_sum / count_greeks
        gamma_avg = gamma_sum / count_greeks
    else:
        avg_iv, theta_avg, vega_avg, delta_avg, gamma_avg = 0.0, 0.0, 0.0, 0.0, 0.0

    vix_instrument_key = "NSE_INDEX|INDIA VIX"
    india_vix_ltp = await get_spot_price_from_upstox(vix_instrument_key, access_token)
    india_vix = round(india_vix_ltp, 2) if india_vix_ltp else 0.0

    straddle_price = 0.0
    if atm_ce_greeks and atm_ce_greeks.get("ltp"):
        straddle_price += atm_ce_greeks["ltp"]
    if atm_pe_greeks and atm_pe_greeks.get("ltp"):
        straddle_price += atm_pe_greeks["ltp"]
    
    pop = 0.5 # Placeholder, requires complex calculation or external data

    market_metrics_data = await get_market_metrics_data(index)

    realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile = await calculate_volatility(config, avg_iv)

    logger.info("Option Seller Dashboard data compiled successfully.")
    return {
        "spot_price": round(spot_price, 2),
        "india_vix": india_vix,
        "nifty_spot": round(spot_price, 2),
        "atm_strike": atm_strike,
        "straddle_price": round(straddle_price, 2),
        "avg_iv": round(avg_iv, 2),
        "theta": round(theta_avg, 2),
        "vega": round(vega_avg, 2),
        "delta": round(delta_avg, 4),
        "gamma": round(gamma_avg, 6),
        "pop": round(pop, 2),
        "pcr": market_metrics_data["pcr"], # Will be None due to Upstox API limitation
        "max_pain": market_metrics_data["max_pain"], # Will be None due to Upstox API limitation
        "days_to_expiry": market_metrics_data["days_to_expiry"],
        "hv_7_day": round(realized_vol_7_day, 2),
        "garch_7_day": round(garch_forecast_7_day, 2),
        "iv_rv_spread": round(iv_rv_spread, 2),
        "iv_percentile": round(iv_percentile, 2)
    }

@app.post("/volguard/strategy-suggestion", response_model=Dict[str, Any])
async def get_strategy_suggestion_endpoint(req: StrategyRequest, 
                                           index: str = Query("NIFTY", description="Index for strategy suggestion: NIFTY or SENSEX"),
                                           access_token: str = Depends(get_upstox_access_token_dep)):
    """
    Provides strategy suggestions based on market conditions.
    """
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")

    config = await get_config(access_token)

    expiries_data = await get_expiries_endpoint(index=index, access_token=access_token)
    current_expiry_str = expiries_data.get("current_expiry")
    if not current_expiry_str:
        raise HTTPException(status_code=404, detail=f"Could not determine current expiry for {index}.")
    
    days_to_expiry = (datetime.strptime(current_expiry_str, "%Y-%m-%d").date() - date.today()).days
    if days_to_expiry < 0: days_to_expiry = 0

    nifty_spot_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}{' 50' if index.lower() == 'nifty' else ''}"
    spot_price = await get_spot_price_from_upstox(nifty_spot_key, access_token)
    if spot_price is None:
        raise HTTPException(status_code=404, detail=f"Could not fetch spot price for {index} to get approximate IV.")

    atm_strike = int(round(spot_price / 100) * 100)
    
    option_chain = await get_option_chain_from_upstox(index, current_expiry_str, access_token)
    atm_ce_greeks = None
    if atm_strike in option_chain and option_chain[atm_strike]["CE"]:
        atm_ce_greeks = await get_option_greeks_from_upstox(option_chain[atm_strike]["CE"]["instrument_token"], access_token)
    
    avg_iv = atm_ce_greeks.get("iv", 0.0) if atm_ce_greeks else 0.0

    realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile = await calculate_volatility(config, avg_iv)

    regime_score = await calculate_regime_score(access_token, index)

    suggested_strategies = await suggest_strategy(iv_percentile, regime_score, days_to_expiry)
    return {"suggested_strategies": suggested_strategies, "request": req.dict()}

@app.get("/volguard/regime-classification", response_model=Dict[str, float])
async def get_regime_classification_endpoint(index: str = Query("NIFTY", description="Index for regime classification: NIFTY or SENSEX"),
                                            access_token: str = Depends(get_upstox_access_token_dep)):
    """
    Returns the multi-factor regime classification score.
    """
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")
    regime_score = await calculate_regime_score(access_token, index)
    return {"regime_score": round(regime_score, 4)}

@app.post("/volguard/risk-evaluation", response_model=Dict[str, Any])
async def perform_risk_evaluation(req: RiskEvaluationRequest):
    """
    Performs position-level and portfolio-level risk evaluation.
    This endpoint relies on the active_trades provided in the request body.
    """
    risk_assessment = await evaluate_risk(req.active_trades)
    return {"risk_assessment": risk_assessment}

@app.get("/volguard/financial-year", response_model=Dict[str, str])
async def get_current_financial_year():
    """
    Returns the current Indian financial year.
    """
    current_date = datetime.now()
    fy = get_financial_year(current_date)
    return {"financial_year": fy}

@app.post("/volguard/predict-volatility", response_model=Dict[str, float])
async def predict_volatility(
    input_features: VolatilityPredictionInput,
    # The XGBoost model doesn't inherently need the Upstox access token for prediction
    # unless its features are dynamically derived from live market data requiring the token.
    # For this placeholder, we'll keep it optional or remove if features are entirely static.
    # access_token: str = Depends(get_upstox_access_token_dep)
):
    """
    Predicts future volatility using the pre-loaded XGBoost model.
    The input features (feature1, feature2, feature3) are placeholders.
    You will need to replace these with the actual features
    that your `xgb_vol_model_v2.pkl` model was trained on.
    """
    global XGB_MODEL
    if XGB_MODEL is None:
        raise HTTPException(status_code=503, detail="XGBoost model not loaded. Please check server startup logs.")

    try:
        # Convert input features to a format the model expects (e.g., numpy array or DataFrame row)
        # This is a placeholder for actual feature engineering/selection.
        # Ensure the order and type of features match the model's training data.
        model_input = np.array([[
            input_features.feature1,
            input_features.feature2,
            input_features.feature3
        ]])

        prediction = XGB_MODEL.predict(model_input)[0]
        return {"predicted_volatility": float(prediction)}
    except Exception as e:
        logger.error(f"Error during volatility prediction: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to make volatility prediction: {str(e)}")

# WebSocket endpoint for real-time data
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    logger.info("WebSocket client connected.")
    try:
        # NOTE ON REAL-TIME DATA:
        # A fully working real-time data feed from Upstox's WebSocket API
        # would require establishing a separate WebSocket CLIENT connection
        # to Upstox (e.g., using `websockets` library on the server side)
        # Authenticating that client connection, subscribing to specific instrument keys,
        # and then relaying the data received from Upstox to THIS FastAPI
        # WebSocket endpoint (the SERVER).
        # This requires persistent background tasks or a dedicated data streaming service
        # beyond what can be directly embedded and managed within a single
        # FastAPI endpoint function call.
        # The structure below is for clients connecting TO THIS SERVER's WebSocket.
        # To get Upstox data, you'd need to:
        # 1. Establish a websocket.connect() to Upstox in a background task.
        # 2. Authenticate and subscribe to desired instrument keys.
        # 3. Process incoming messages from Upstox.
        # 4. Use `await websocket.send_json()` (or similar) to push that data
        #    to all connected clients of this `/ws` endpoint.
        
        while True:
            # Example: If you had a background task pushing data into a queue,
            # you would retrieve from that queue here and send.
            # await websocket.send_json({"message": "Real-time data placeholder: Implement Upstox WebSocket client in background."})
            await websocket.receive_text() # Keep connection alive or receive client messages
            # For a real push, you'd have client subscribe to instruments and then stream
            # data back from a background process that is connected to Upstox.
    except WebSocketDisconnect:
        logger.info("WebSocket client disconnected.")
    except Exception as e:
        logger.error(f"WebSocket error: {e}")

