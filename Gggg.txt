import os
import logging
import pandas as pd
import numpy as np
import httpx
import pickle
from io import BytesIO
from datetime import datetime, timedelta, date
from arch import arch_model
from scipy.stats import linregress
from fastapi import FastAPI, Depends, HTTPException, Query, Request, WebSocket, WebSocketDisconnect, Body, APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, ValidationError
from typing import List, Optional, Dict, Any, Set, Union # Import Union

import websockets

# --- ENVIRONMENT VARIABLES ---
# These environment variables must be set in your Render environment for the backend to function correctly.
# Example: SUPABASE_URL="https://your-project-id.supabase.co"
# Example: SUPABASE_KEY="your-supabase-anon-key"
# Example: UPSTOX_API_KEY="your_upstox_api_key"
# Example: UPSTOX_API_SECRET="your_upstox_api_secret"
# Example: UPSTOX_REDIRECT_URI="http://localhost:8000/auth/callback" # Or your Render callback URL

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
XG_BOOST_MODEL_URL = os.getenv("XG_BOOST_MODEL_URL", "https://raw.githubusercontent.com/shritish20/VolGuard-Pro/main/xgb_vol_model_v2.pkl")
NIFTY_HIST_URL = os.getenv("NIFTY_HIST_URL", "https://raw.githubusercontent.com/shritish20/VolGuard/main/nifty_50.csv")
IVP_HIST_URL = os.getenv("IVP_HIST_URL", "https://raw.githubusercontent.com/shritish20/VolGuard/main/ivp.csv")
UPCOMING_EVENTS_URL = os.getenv("UPCOMING_EVENTS_URL", "https://raw.githubusercontent.com/shritish20/VolGuard/main/upcoming_events.csv")
UPSTOX_API_KEY = os.getenv("UPSTOX_API_KEY")
UPSTOX_API_SECRET = os.getenv("UPSTOX_API_SECRET")
UPSTOX_REDIRECT_URI = os.getenv("UPSTOX_REDIRECT_URI")

# Ensure critical environment variables are set
if not SUPABASE_URL or not SUPABASE_KEY:
    raise ValueError("Supabase URL and Key must be set as environment variables.")
if not UPSTOX_API_KEY or not UPSTOX_API_SECRET or not UPSTOX_REDIRECT_URI:
    raise ValueError("Upstox API Key, API Secret, and Redirect URI must be set as environment variables.")

# --- LOGGING SETUP ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- SUPABASE CLIENT ---
SUPABASE_HEADERS = {
    "apikey": SUPABASE_KEY,
    "Content-Type": "application/json",
    "Prefer": "return=representation"
}

# In-memory store for access tokens (for demonstration/testing purposes,
# in a production environment, this should be a secure, persistent store like Redis or a database)
# You will need to implement a proper OAuth2 flow to obtain and manage access tokens.
# This global variable will hold the access token after a successful login.
ACCESS_TOKEN_STORE: Dict[str, Any] = {"access_token": None, "expiry_time": None}

async def get_current_access_token() -> Optional[str]:
    """Retrieves the current valid access token from the store."""
    if ACCESS_TOKEN_STORE["access_token"] and ACCESS_TOKEN_STORE["expiry_time"] and \
       datetime.now() < ACCESS_TOKEN_STORE["expiry_time"]:
        return ACCESS_TOKEN_STORE["access_token"]
    return None

async def refresh_access_token(code: str) -> bool:
    """
    Exchanges authorization code for an access token and refreshes it.
    This is a simplified example; a full OAuth2 implementation would handle refresh tokens.
    """
    token_url = "https://api-v2.upstox.com/v2/login/authorization/token"
    payload = {
        "code": code,
        "client_id": UPSTOX_API_KEY,
        "client_secret": UPSTOX_API_SECRET,
        "redirect_uri": UPSTOX_REDIRECT_URI,
        "grant_type": "authorization_code"
    }
    headers = {
        "accept": "application/json",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(token_url, data=payload, headers=headers)
            response.raise_for_status()
            token_data = response.json()
            ACCESS_TOKEN_STORE["access_token"] = token_data.get("access_token")
            # Set expiry time based on expires_in (seconds)
            expires_in = token_data.get("expires_in", 3600)  # Default to 1 hour if not provided
            ACCESS_TOKEN_STORE["expiry_time"] = datetime.now() + timedelta(seconds=expires_in - 300) # 5 min buffer
            logger.info("Access token refreshed successfully.")
            return True
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error refreshing token: {e.response.status_code} - {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error refreshing token: {e}")
    return False

# Dependency to get access token for protected routes
async def get_upstox_access_token_dep() -> str:
    token = await get_current_access_token()
    if not token:
        raise HTTPException(status_code=401, detail="Upstox access token not available or expired. Please authorize.")
    return token

async def log_trade_to_supabase(data: dict):
    # Ensure timestamp_entry and timestamp_exit are present, handling optional fields
    data["timestamp_entry"] = data.get("timestamp_entry", datetime.utcnow().isoformat() + "Z")
    data["timestamp_exit"] = data.get("timestamp_exit", datetime.utcnow().isoformat() + "Z")
    data["status"] = data.get("status", "closed")
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(f"{SUPABASE_URL}/rest/v1/trade_logs", json=data, headers=SUPABASE_HEADERS)
            response.raise_for_status()
            logger.info(f"Trade logged to Supabase: {response.json()}")
            return response.status_code, response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error logging trade to Supabase: {e.response.status_code} - {e.response.text}")
        return e.response.status_code, {"error": e.response.text}
    except httpx.RequestError as e:
        logger.error(f"Network error logging trade to Supabase: {e}")
        return 500, {"error": str(e)}

async def add_journal_to_supabase(data: dict):
    """Adds a journal entry to Supabase."""
    data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(f"{SUPABASE_URL}/rest/v1/journals", json=data, headers={**SUPABASE_HEADERS, "Authorization": f"Bearer {SUPABASE_KEY}"})
            response.raise_for_status()
            logger.info(f"Journal entry added to Supabase: {response.json()}")
            return response.status_code, response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error adding journal to Supabase: {e.response.status_code} - {e.response.text}")
        return e.response.status_code, {"error": e.response.text}
    except httpx.RequestError as e:
        logger.error(f"Network error adding journal to Supabase: {e}")
        return 500, {"error": str(e)}

# --- FastAPI Setup ---
app = FastAPI(title="VoluGuard API", description="Comprehensive API for Volatility Analysis, Strategy Suggestion, Risk Management, and Trade Logging.")

# --- FastAPI Models ---
class UpstoxOrderRequest(BaseModel):
    transaction_type: str
    instrument_key: str
    product: str
    price: Optional[float] = 0.0
    quantity: int

class GTTOrderRequest(BaseModel):
    transaction_type: str
    instrument_key: str
    product: str
    price: float
    trigger_price: float
    quantity: int
    time_in_force: str = "GTT"
    trigger_type: str = "single"
    order_type: str = "limit"

class TradeRequest(BaseModel):
    strategy: str
    instrument_token: str
    entry_price: float
    quantity: float
    realized_pnl: float
    unrealized_pnl: float
    regime_score: Optional[float] = None
    notes: Optional[str] = ""
    capital_used: Optional[float] = None
    potential_loss: Optional[float] = None
    sl_hit: Optional[bool] = False
    vega: Optional[float] = None
    timestamp_entry: Optional[str] = None
    timestamp_exit: Optional[str] = None
    status: Optional[str] = "closed"

class JournalRequest(BaseModel):
    title: str
    content: str
    mood: str
    tags: Optional[str] = ""

class StrategyRequest(BaseModel):
    strategy: str
    lots: int = Field(1, ge=1)

class RiskEvaluationRequest(BaseModel):
    active_trades: List[TradeRequest]

# New Pydantic model for individual leg of a multi-leg order
class OrderLeg(BaseModel):
    strike: int
    option_type: str # "CE" or "PE"
    quantity: int
    transaction_type: str # "BUY" or "SELL"
    order_type: str # "MARKET" or "LIMIT"
    price: Optional[float] = None # Required if order_type is LIMIT

class PlaceOrderInput(BaseModel):
    index: str # "nifty" or "sensex"
    expiry: str # string (yyyy-mm-dd)
    gtt: Optional[bool] = False
    legs: List[OrderLeg] # List of order legs for multi-leg strategies

class ModifyOrderInput(BaseModel):
    order_id: str
    quantity: Optional[int] = None
    price: Optional[float] = None
    order_type: Optional[str] = None
    trigger_price: Optional[float] = None # For GTT or SL orders

class OrderStatusResponse(BaseModel):
    exchange_order_id: str
    tradingsymbol: str
    instrument_token: str
    quantity: int
    price: float
    status: str
    # Add other relevant fields from Upstox order details
    average_price: Optional[float] = None
    transaction_type: Optional[str] = None
    product: Optional[str] = None
    order_type: Optional[str] = None
    validity: Optional[str] = None
    # ... more fields as per Upstox API response

class ModifyOrderResponse(BaseModel):
    status: str
    message: Optional[str] = None
    order_id: Optional[str] = None
    # Add other relevant fields from Upstox modify order response

# --- Helper Functions for Database (Supabase) ---
async def get_all_trades(status: Optional[str] = None):
    """Fetches all logged trade entries from Supabase, with optional status filter."""
    try:
        async with httpx.AsyncClient() as client:
            url = f"{SUPABASE_URL}/rest/v1/trade_logs"
            headers = {**SUPABASE_HEADERS, "Authorization": f"Bearer {SUPABASE_KEY}"}
            if status:
                url += f"?status=eq.{status}"
            response = await client.get(url, headers=headers)
            response.raise_for_status()
            logger.info("Successfully fetched trades from Supabase.")
            return response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching trades: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching trades: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching trades: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching trades: {str(e)}")

async def get_all_journals():
    """Fetches all logged journal entries from Supabase."""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{SUPABASE_URL}/rest/v1/journals", headers={**SUPABASE_HEADERS, "Authorization": f"Bearer {SUPABASE_KEY}"})
            response.raise_for_status()
            logger.info("Successfully fetched journals from Supabase.")
            return response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching journals: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching journals: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching journals: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching journals: {str(e)}")

# --- VolGuard Core Logic (Fully Merged from Original main.txt) ---

def get_financial_year(date_obj: datetime) -> str:
    """
    Returns capped Indian financial year in 'YYYY-YYYY' format.
    Caps to '2025-2026' if system date leads to '2025-2026'.
    """
    if date_obj.month >= 4:
        fy_start = date_obj.year
    else:
        fy_start = date_obj.year - 1

    fy_end = fy_start + 1

    # CAP to current allowed maximum year (Upstox limit)
    # This might need dynamic adjustment if Upstox changes its F&O expiry range
    if fy_start >= 2025: # Assuming 2025-2026 is the current limit
        return "2025-2026"

    return f"{fy_start}-{fy_end}"

# Global variable to store the XGBoost model
XGB_MODEL = None

async def load_xgboost_model():
    """Loads the XGBoost model from the specified URL."""
    global XGB_MODEL
    if XGB_MODEL is None:
        logger.info(f"Attempting to load XGBoost model from {XG_BOOST_MODEL_URL}")
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(XG_BOOST_MODEL_URL)
                response.raise_for_status()
                model_data = BytesIO(response.content)
                XGB_MODEL = pickle.load(model_data)
                logger.info("XGBoost model loaded successfully.")
        except httpx.HTTPStatusError as e:
            logger.error(f"Failed to fetch XGBoost model: HTTP error {e.response.status_code} - {e.response.text}")
            XGB_MODEL = None # Ensure model is None on failure
            raise HTTPException(status_code=500, detail=f"Failed to load XGBoost model: {e.response.text}")
        except Exception as e:
            logger.error(f"Error loading XGBoost model: {e}")
            XGB_MODEL = None # Ensure model is None on failure
            raise HTTPException(status_code=500, detail=f"Error loading XGBoost model: {e}")
    return XGB_MODEL

async def fetch_historical_data(url: str):
    """Fetches historical data (e.g., Nifty 50 or IVP) from a given URL."""
    logger.info(f"Fetching historical data from {url}...")
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url)
            response.raise_for_status()
            df = pd.read_csv(BytesIO(response.content), index_col='Date', parse_dates=True)
            logger.info(f"Historical data from {url} fetched successfully.")
            return df
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching historical data from {url}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=500, detail=f"Error fetching historical data: {e.response.text}")
    except Exception as e:
        logger.error(f"Error fetching or parsing historical data from {url}: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching or parsing historical data: {str(e)}")

async def calculate_volatility(config: Dict[str, Any], avg_iv: float):
    """
    Calculates volatility metrics: GARCH(1,1), IV-RV spread, IV Percentile, Realized Vol.
    Assumes `nifty_data` and `ivp_data` are available (fetched from URLs).
    """
    logger.info(f"Calculating volatility with avg_iv: {avg_iv}...")

    nifty_data = await fetch_historical_data(config["nifty_url"])
    ivp_data = await fetch_historical_data(config["ivp_url"])

    if nifty_data.empty or ivp_data.empty:
        raise HTTPException(status_code=500, detail="Failed to load historical data for volatility calculation.")

    # Convert 'Close' to numeric, handling potential non-numeric data
    nifty_data['Close'] = pd.to_numeric(nifty_data['Close'], errors='coerce')
    nifty_data.dropna(subset=['Close'], inplace=True)

    if nifty_data.empty or len(nifty_data) < 2:
        raise HTTPException(status_code=500, detail="Insufficient historical Nifty data for volatility calculation.")

    # Calculate daily returns
    nifty_data['Returns'] = np.log(nifty_data['Close'] / nifty_data['Close'].shift(1))
    nifty_data.dropna(inplace=True)

    if nifty_data.empty:
        raise HTTPException(status_code=500, detail="No valid returns for volatility calculation.")

    # Realized Volatility (7-day annualized)
    # Ensure there are enough data points for a 7-day window
    if len(nifty_data) >= 7:
        realized_vol_7_day = nifty_data['Returns'].rolling(window=7).std().iloc[-1] * np.sqrt(252) * 100
    else:
        realized_vol_7_day = 0.0 # Not enough data for 7-day, handle appropriately

    # GARCH(1,1) Volatility (7-day forecast)
    try:
        if len(nifty_data) < 100: # Need sufficient data for GARCH
             logger.warning("Not enough data for robust GARCH model, using simpler estimate.")
             garch_forecast_7_day = avg_iv # Fallback to avg_iv if data insufficient
        else:
            model = arch_model(nifty_data['Returns'] * 100, vol='Garch', p=1, q=1)
            res = model.fit(disp='off')
            # Forecast 7 days ahead, then annualize
            forecast = res.forecast(horizon=7)
            garch_variance = forecast.variance.iloc[-1]
            # Convert daily variance to daily standard deviation, then annualize for 7 days
            garch_forecast_7_day = np.sqrt(garch_variance).mean() * np.sqrt(252)
    except Exception as e:
        logger.error(f"Error in GARCH model: {e}. Falling back to avg_iv.")
        garch_forecast_7_day = avg_iv

    # IV-RV Spread
    iv_rv_spread = avg_iv - realized_vol_7_day

    # IV Percentile
    # Ensure 'IV' column exists in ivp_data and is numeric
    ivp_data['IV'] = pd.to_numeric(ivp_data['IV'], errors='coerce')
    ivp_data.dropna(subset=['IV'], inplace=True)

    if ivp_data.empty:
        iv_percentile = 0.5 # Default if no IVP data
    else:
        iv_percentile = (avg_iv > ivp_data['IV']).mean()

    return realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile


async def get_market_metrics_data(access_token: str, index: str):
    """
    Fetches market metrics data (like PCR, Max Pain, Days to Expiry) dynamically.
    For PCR and Max Pain, this often requires extensive option chain analysis,
    which can be complex to do purely from Upstox /option/contract and /market-quote endpoints
    without external tools or significant processing.
    For this build, we will simulate these or keep them simple based on available Upstox data.
    Days to Expiry is calculated from the dynamic expiry.
    """
    logger.info("Fetching market metrics data...")
    
    # Get current expiry for 'days_to_expiry'
    expiries_data = await get_expiries_endpoint(index=index, access_token=access_token)
    current_expiry_str = expiries_data.get("current_expiry")
    
    days_to_expiry = 0
    if current_expiry_str:
        current_expiry_date = datetime.strptime(current_expiry_str, "%Y-%m-%d").date()
        days_to_expiry = (current_expiry_date - date.today()).days
        if days_to_expiry < 0: # If current expiry has passed, find the next one
            # This is already handled in get_expiries_endpoint, but a double check.
            # For simplicity, if negative, assume 0 or consider it a past expiry which shouldn't happen with the logic above
            days_to_expiry = 0

    # PCR and Max Pain are harder to derive directly from simple Upstox API calls
    # without downloading full historical and live option chain and calculating
    # Open Interest. For a production system, this would typically involve:
    # 1. Fetching all CE/PE contracts for an expiry.
    # 2. Fetching live Open Interest for each contract (if available, Upstox has `/v2/historical-open-interest` for history).
    # 3. Summing OI for CEs and PEs at each strike to determine Max Pain.
    # 4. Calculating Put-Call Ratio from total OI or traded volume.

    # For now, these will be placeholders or based on a simplified logic.
    pcr = 1.0 # Placeholder
    max_pain = 0 # Placeholder, would depend on the index and option chain

    if index.lower() == "nifty":
        max_pain = 23000 # Example placeholder for Nifty
    elif index.lower() == "sensex":
        max_pain = 75000 # Example placeholder for Sensex
    
    # A simplified PCR calculation based on spot price and option types (very basic)
    # This would need a more robust implementation using actual OI data.
    # This is a place where live OI data from Upstox would be integrated.
    # As per openapi.txt, `/v2/historical-open-interest` exists, but not for live.
    # For a *real* solution, streaming data or a dedicated OI endpoint would be needed.

    return {
        "pcr": pcr,
        "max_pain": max_pain,
        "days_to_expiry": days_to_expiry
    }

async def calculate_regime_score(access_token: str, index: str):
    """
    Calculates a multi-factor regime score.
    This is a complex module that would ideally involve:
    - Volatility (Realized, IV, GARCH)
    - Trend (e.g., moving averages, ADX)
    - Sentiment (e.g., PCR, VIX)
    - Macroeconomic factors
    """
    logger.info("Calculating regime score...")

    # Fetch relevant market data for regime classification
    try:
        nifty_spot_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}{' 50' if index.lower() == 'nifty' else ''}"
        spot_price = await get_spot_price_from_upstox(nifty_spot_key, access_token)
        
        # Placeholder for average IV. In a real scenario, this would involve
        # fetching option chain and calculating ATM IV or a weighted average IV.
        # For now, using a dummy value or deriving from option Greeks if possible.
        # This needs a more direct way to get overall IV for the index.
        # For a full implementation, you'd fetch option chain, then get Greeks for ATM options to derive average IV.
        avg_iv = 15.0 # Dummy average IV

        # Use the volatility calculation for some inputs
        config = await get_config(access_token) # Get the full config to access historical data URLs
        realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile = await calculate_volatility(config, avg_iv)

        # Additional factors (placeholders for now)
        trend_strength = 0.6 # From trend analysis
        sentiment_score = 0.8 # From PCR, VIX, etc.
        
        # Simple weighted average for regime score
        regime_score = (
            (realized_vol_7_day / 50.0) * 0.2 + # Normalize RV
            (garch_forecast_7_day / 50.0) * 0.2 + # Normalize GARCH
            (iv_percentile) * 0.2 + # IVP is already 0-1
            trend_strength * 0.2 +
            sentiment_score * 0.2
        )
        regime_score = min(1.0, max(0.0, regime_score)) # Cap between 0 and 1

        return regime_score
    except Exception as e:
        logger.error(f"Error calculating regime score: {e}")
        return 0.5 # Default/neutral score on error

async def evaluate_risk(active_trades: List[TradeRequest]):
    """
    Performs position-level, portfolio-level checks, and behavioral rules.
    This is a complex module involving real-time market data, P&L calculations,
    and user-defined risk limits.
    """
    logger.info(f"Evaluating risk for {len(active_trades)} trades...")
    
    # Example: Calculate total unrealized PnL
    total_unrealized_pnl = sum(trade.unrealized_pnl for trade in active_trades)
    
    # Example: Check capital deployed vs. limits
    total_capital_deployed = sum(trade.capital_used for trade in active_trades if trade.capital_used is not None)
    
    # Dummy config for risk limits (in a real app, fetch from user settings or config)
    mock_total_funds = 2000000 # Example total funds
    daily_risk_limit = mock_total_funds * 0.02 # 2% daily risk limit

    # Check if total unrealized loss exceeds daily risk limit
    exceeds_daily_limit = False
    if total_unrealized_pnl < 0 and abs(total_unrealized_pnl) > daily_risk_limit:
        exceeds_daily_limit = True

    # Behavioral rules (examples)
    # - Too many concurrent trades
    # - Too much capital allocated to one strategy/instrument
    # - High gamma exposure
    
    overall_risk = "low"
    if exceeds_daily_limit:
        overall_risk = "high"
    elif total_capital_deployed > mock_total_funds * 0.5: # Example: more than 50% capital deployed
        overall_risk = "medium"

    return {
        "overall_risk": overall_risk,
        "exceeds_daily_limit": exceeds_daily_limit,
        "total_unrealized_pnl": total_unrealized_pnl,
        "total_capital_deployed": total_capital_deployed
    }

async def suggest_strategy(iv_percentile: float, regime_score: float, days_to_expiry: int):
    """
    Suggests options strategies based on IV Percentile, Regime Score, and Days to Expiry.
    This implements the core VolGuard strategy suggestion logic.
    """
    logger.info(f"Suggesting strategy for IVP: {iv_percentile}, Regime Score: {regime_score}, DTE: {days_to_expiry}...")

    suggestions = []

    # Strategy based on IV Percentile
    if iv_percentile >= 0.70: # High IVP: Sell premium
        suggestions.append("Iron Condor (High IVP)")
        suggestions.append("Short Straddle/Strangle (High IVP)")
        suggestions.append("Jade Lizard (High IVP, bullish bias)")
    elif iv_percentile <= 0.30: # Low IVP: Buy premium
        suggestions.append("Long Straddle/Strangle (Low IVP)")
        suggestions.append("Calendar Spread (Low IVP, time decay)")
        suggestions.append("Bull/Bear Spreads (Low IVP, directional)")
    else: # Medium IVP
        suggestions.append("Iron Fly (Medium IVP, neutral)")
        suggestions.append("Credit Spreads (Medium IVP, directional bias)")

    # Adjust based on Regime Classification (simplified example)
    if regime_score >= 0.7: # Bullish/Strong Up-trend
        if "Iron Condor (High IVP)" in suggestions:
            suggestions.remove("Iron Condor (High IVP)") # Less optimal for strong trend
        if "Short Straddle/Strangle (High IVP)" in suggestions:
            suggestions.remove("Short Straddle/Strangle (High IVP)")
        suggestions.append("Bull Call Spread (Strong Bullish)")
        suggestions.append("Short Put (Strong Bullish)")
    elif regime_score <= 0.3: # Bearish/Strong Down-trend
        if "Iron Condor (High IVP)" in suggestions:
            suggestions.remove("Iron Condor (High IVP)")
        if "Short Straddle/Strangle (High IVP)" in suggestions:
            suggestions.remove("Short Straddle/Strangle (High IVP)")
        suggestions.append("Bear Put Spread (Strong Bearish)")
        suggestions.append("Short Call (Strong Bearish)")

    # Adjust based on Days to Expiry
    if days_to_expiry < 7: # Short-term expiry (more theta decay)
        # Prioritize theta positive strategies
        if "Iron Condor (High IVP)" in suggestions:
            pass # Keep if already suggested
        elif "Iron Condor (High IVP)" not in suggestions and iv_percentile >= 0.70:
            suggestions.append("Iron Condor (Short DTE, High IVP)")
        if "Short Straddle/Strangle (High IVP)" in suggestions:
            pass
        elif "Short Straddle/Strangle (High IVP)" not in suggestions and iv_percentile >= 0.70:
            suggestions.append("Short Straddle/Strangle (Short DTE, High IVP)")
        
        # Remove strategies that require more time
        for s in ["Calendar Spread (Low IVP, time decay)", "Long Straddle/Strangle (Low IVP)"]:
            if s in suggestions: suggestions.remove(s)

    elif days_to_expiry > 30: # Long-term expiry (less theta decay, more vega sensitivity)
        # Can consider buying strategies or wider spreads
        if iv_percentile <= 0.30 and "Long Straddle/Strangle (Low IVP)" not in suggestions:
            suggestions.append("Long Straddle/Strangle (Long DTE, Low IVP)")
        if "Calendar Spread (Low IVP, time decay)" not in suggestions:
             suggestions.append("Calendar Spread (Long DTE, Low IVP)")

    # Remove duplicates and return
    return list(set(suggestions))

# --- CONFIGURATION & UPSTOX API SETUP ---
def get_upstox_headers(access_token: str) -> Dict[str, str]:
    """
    Returns standard headers for Upstox API calls, including Authorization.
    """
    return {
        "accept": "application/json",
        "Api-Version": "2.0", # Defaulting to 2.0 for general calls, will override for V3 where needed
        "Authorization": f"Bearer {access_token}"
    }

async def get_config(access_token: str) -> Dict[str, Any]:
    """
    Retrieves dynamic configuration, including Upstox API headers and general settings.
    Expiry and instrument details will be fetched dynamically via specific endpoints.
    """
    upstox_headers = get_upstox_headers(access_token)
    config = {
        "base_url": "https://api.upstox.com/v2",
        "v3_url": "https://api-v2.upstox.com/v3", # Corrected V3 URL as per openapi.txt
        "headers": upstox_headers,
        "nifty_url": NIFTY_HIST_URL,
        "ivp_url": IVP_HIST_URL,
        "event_url": UPCOMING_EVENTS_URL,
        "total_funds": 2000000, # Default total funds, can be made dynamic
        "risk_config": {
            "Iron Fly": {"capital_pct": 0.30, "risk_per_trade_pct": 0.01},
            "Iron Condor": {"capital_pct": 0.25, "risk_per_trade_pct": 0.015},
            "Jade Lizard": {"capital_pct": 0.20, "risk_per_trade_pct": 0.01},
            "Straddle": {"capital_pct": 0.15, "risk_per_trade_pct": 0.02},
            "Calendar Spread": {"capital_pct": 0.10, "risk_per_trade_pct": 0.01},
            "Bull Put Spread": {"capital_pct": 0.15, "risk_per_trade_pct": 0.01},
            "Wide Strangle": {"capital_pct": 0.10, "risk_per_trade_pct": 0.015},
            "ATM Strangle": {"capital_pct": 0.10, "risk_per_trade_pct": 0.015}
        },
        "daily_risk_limit_pct": 0.02,
        "weekly_risk_limit_pct": 0.03,
        "lot_size": 50 # Nifty lot size as of recent changes (was 75) - adjust if needed
    }
    try:
        async with httpx.AsyncClient() as client:
            # Fetch funds and margin
            funds_resp = await client.get(f"{config['base_url']}/user/get-funds-and-margin", headers=config['headers'])
            funds_resp.raise_for_status()
            funds = funds_resp.json()["data"]["equity"]
            config["available_margin"] = float(funds["available_margin"] or 0)
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching funds: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching funds: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching funds: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching funds: {str(e)}")
    return config

# --- Upstox API Integration ---

# Helper to map index to instrument key prefix
INDEX_TO_INSTRUMENT_PREFIX = {
    "nifty": "NSE_INDEX",
    "sensex": "BSE_INDEX"
}

INDEX_TO_CONTRACT_SYMBOL = {
    "nifty": "NIFTY",
    "sensex": "SENSEX"
}

async def get_expiries_from_upstox(index: str, access_token: str) -> List[str]:
    """
    Fetches all available expiry dates for a given index from Upstox.
    Uses /option/contract to pull all expiries.
    """
    # Construct the base instrument key for the index
    base_instrument_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}"
    if index.lower() == "nifty": # Nifty uses "NIFTY 50"
        base_instrument_key += " 50"

    url = "https://api-v2.upstox.com/v2/option/contract"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": base_instrument_key}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()["data"]
            all_expiries = sorted(list(set(item["expiry"] for item in data)))
            return all_expiries
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching expiries for {index}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching expiries: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching expiries for {index}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching expiries: {str(e)}")

async def get_option_chain_from_upstox(index: str, expiry: str, access_token: str) -> Dict[str, Any]:
    """
    Fetches the full option chain for a given index and expiry from Upstox.
    Groups by strike and option type (CE/PE).
    """
    instrument_key_prefix = INDEX_TO_INSTRUMENT_PREFIX[index.lower()]
    contract_symbol = INDEX_TO_CONTRACT_SYMBOL[index.lower()]
    
    base_instrument_key_filter = f"{instrument_key_prefix}|{contract_symbol}"
    if index.lower() == "nifty":
        base_instrument_key_filter += " 50"

    url = "https://api-v2.upstox.com/v2/option/contract"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": base_instrument_key_filter}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            all_contracts = response.json()["data"]

            option_chain = {}
            for contract in all_contracts:
                # Upstox returns expiry in 'YYYY-MM-DD' format, ensure consistent comparison
                if contract["expiry"] == expiry:
                    strike_price = int(contract["strike_price"])
                    option_type = contract["option_type"] # 'CE' or 'PE'
                    instrument_token = contract["instrument_key"]

                    if strike_price not in option_chain:
                        option_chain[strike_price] = {"CE": None, "PE": None}
                    
                    option_chain[strike_price][option_type] = {
                        "instrument_token": instrument_token,
                        "strike_price": strike_price,
                        "option_type": option_type,
                        "expiry": expiry
                    }
            return option_chain
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching option chain for {index} expiry {expiry}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching option chain: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching option chain for {index} expiry {expiry}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching option chain: {str(e)}")

async def get_instrument_token(index: str, strike: int, expiry: str, option_type: str, access_token: str) -> Optional[str]:
    """
    Resolves instrument token for a given option contract using the option chain.
    """
    option_chain = await get_option_chain_from_upstox(index, expiry, access_token)
    if strike in option_chain and option_chain[strike][option_type]:
        return option_chain[strike][option_type]["instrument_token"]
    return None

async def get_spot_price_from_upstox(instrument_key: str, access_token: str) -> Optional[float]:
    """
    Gets the real-time Last Traded Price (LTP) for a given instrument key.
    """
    url = "https://api-v2.upstox.com/v2/market-quote/ltp"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": instrument_key}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()["data"]
            if instrument_key in data and data[instrument_key]:
                return data[instrument_key].get("ltp")
            return None
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching LTP for {instrument_key}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching LTP: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching LTP for {instrument_key}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching LTP: {str(e)}")

async def get_option_greeks_from_upstox(instrument_key: str, access_token: str) -> Optional[Dict[str, Any]]:
    """
    Gets option Greeks (IV, delta, theta, vega, gamma) for a given instrument key.
    """
    url = "https://api-v2.upstox.com/v2/market-quote/option-greek"
    headers = get_upstox_headers(access_token)
    params = {"instrument_key": instrument_key}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()["data"]
            if instrument_key in data and data[instrument_key]:
                return data[instrument_key]
            return None
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching option Greeks for {instrument_key}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching option Greeks: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching option Greeks for {instrument_key}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching option Greeks: {str(e)}")

async def get_market_timings_from_upstox(exchange: Optional[str] = None, product_type: Optional[str] = None, access_token: str) -> Dict[str, Any]:
    """
    Gets market timings and holiday information from Upstox.
    """
    url = "https://api-v2.upstox.com/v2/market/timings"
    headers = get_upstox_headers(access_token)
    params = {}
    if exchange:
        params["exchange"] = exchange
    if product_type:
        params["product_type"] = product_type

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            return response.json()["data"]
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching market timings: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching market timings: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching market timings: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching market timings: {str(e)}")

# --- FastAPI Endpoints ---

@app.on_event("startup")
async def startup_event():
    """Load XGBoost model on application startup."""
    await load_xgboost_model()

@app.get("/auth/login")
async def login():
    """
    Initiates the Upstox OAuth2 login process.
    Redirects to Upstox authorization URL.
    """
    auth_url = "https://api-v2.upstox.com/v2/login/authorization/dialog"
    params = {
        "response_type": "code",
        "client_id": UPSTOX_API_KEY,
        "redirect_uri": UPSTOX_REDIRECT_URI
    }
    # Build the URL manually to ensure it's correct
    query_string = "&".join([f"{k}={v}" for k, v in params.items()])
    full_auth_url = f"{auth_url}?{query_string}"
    return JSONResponse(content={"authorization_url": full_auth_url})

@app.get("/auth/callback")
async def auth_callback(code: str = Query(..., description="Authorization code from Upstox")):
    """
    Callback endpoint for Upstox OAuth2. Exchanges the authorization code for an access token.
    """
    if await refresh_access_token(code):
        return {"message": "Authentication successful! Access token obtained."}
    raise HTTPException(status_code=400, detail="Failed to obtain access token.")


@app.post("/log-trade", response_model=Dict[str, Any])
async def log_trade(trade: TradeRequest):
    """Logs a trade entry to Supabase."""
    status_code, response_data = await log_trade_to_supabase(trade.dict())
    if status_code in [200, 201]:
        return {"message": "Trade logged successfully", "data": response_data}
    raise HTTPException(status_code=status_code, detail=response_data.get("error", "Failed to log trade."))

@app.get("/get-trades", response_model=Dict[str, List[Dict[str, Any]]])
async def get_trades(status: Optional[str] = Query(None)):
    """Fetches all logged trade entries from Supabase, with optional status filter."""
    trades = await get_all_trades(status)
    return {"trades": trades}

@app.post("/add-journal", response_model=Dict[str, Any])
async def add_journal(journal: JournalRequest):
    """Adds a journal entry to Supabase."""
    status_code, response_data = await add_journal_to_supabase(journal.dict())
    if status_code in [200, 201]:
        return {"message": "Journal entry added successfully", "data": response_data}
    raise HTTPException(status_code=status_code, detail=response_data.get("error", "Failed to add journal entry."))

@app.get("/get-journals", response_model=Dict[str, List[Dict[str, Any]]])
async def get_journals():
    """Fetches all logged journal entries from Supabase."""
    journals = await get_all_journals()
    return {"journals": journals}

@app.get("/expiries", response_model=Dict[str, Optional[str]])
async def get_expiries_endpoint(index: str = Query(..., description="Index name, e.g., NIFTY or SENSEX")):
    """
    Retrieves current, next weekly, and next monthly expiry dates for Nifty or Sensex.
    Automatically detects holidays or special expiry shifts.
    """
    access_token = await get_upstox_access_token_dep() # Dependency for access token
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")

    all_expiries = await get_expiries_from_upstox(index, access_token)
    
    today = date.today()
    current_expiry = None
    next_weekly_expiry = None
    next_monthly_expiry = None

    # Filter out past expiries and convert to datetime objects for easier comparison
    future_expiries_dt = sorted([datetime.strptime(e, "%Y-%m-%d").date() for e in all_expiries if datetime.strptime(e, "%Y-%m-%d").date() >= today])

    if not future_expiries_dt:
        raise HTTPException(status_code=404, detail="No upcoming expiries found.")

    # Current Expiry: The first expiry that is today or in the future
    current_expiry = future_expiries_dt[0].strftime("%Y-%m-%d")

    # Determine next weekly and next monthly expiry
    weekly_expiries = sorted([e for e in future_expiries_dt if e.weekday() == 3]) # Thursday (0=Monday, 3=Thursday)
    
    # Heuristic for monthly expiry: last Thursday of the month
    monthly_expiries = []
    seen_months_years = set()
    for exp_date in future_expiries_dt:
        if exp_date.weekday() == 3: # If it's a Thursday
            # Check if it's the last Thursday of the month
            # By checking if adding 7 days moves to the next month
            if (exp_date + timedelta(days=7)).month != exp_date.month:
                month_year = (exp_date.year, exp_date.month)
                if month_year not in seen_months_years:
                    monthly_expiries.append(exp_date)
                    seen_months_years.add(month_year)
    monthly_expiries = sorted(monthly_expiries)

    # Find next weekly expiry AFTER current_expiry
    for exp in weekly_expiries:
        if exp > datetime.strptime(current_expiry, "%Y-%m-%d").date():
            next_weekly_expiry = exp.strftime("%Y-%m-%d")
            break
    
    # Find next monthly expiry AFTER current_expiry
    for exp in monthly_expiries:
        if exp > datetime.strptime(current_expiry, "%Y-%m-%d").date():
            next_monthly_expiry = exp.strftime("%Y-%m-%d")
            break
    
    return {
        "current_expiry": current_expiry,
        "next_weekly_expiry": next_weekly_expiry,
        "next_monthly_expiry": next_monthly_expiry
    }


@app.get("/option-chain", response_model=Dict[str, Dict[str, Dict[str, Any]]])
async def get_option_chain_endpoint(
    index: str = Query(..., description="Index name, e.g., NIFTY or SENSEX"),
    expiry: str = Query(..., description="Expiry date in YYYY-MM-DD format"),
):
    """
    Retrieves the full option chain for a specified index and expiry.
    """
    access_token = await get_upstox_access_token_dep()
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")
    
    try:
        datetime.strptime(expiry, "%Y-%m-%d")
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid expiry date format. Use YYYY-MM-DD.")

    option_chain_data = await get_option_chain_from_upstox(index, expiry, access_token)
    if not option_chain_data:
        raise HTTPException(status_code=404, detail=f"No option chain found for {index} with expiry {expiry}.")
    return option_chain_data

@app.post("/place-order", response_model=Dict[str, Any])
async def place_order_endpoint(
    order_input: PlaceOrderInput,
):
    """
    Places a regular or GTT order on Upstox. Handles dynamic instrument token fetching
    and multi-leg trades.
    """
    access_token = await get_upstox_access_token_dep()
    
    headers = get_upstox_headers(access_token)
    headers["Api-Version"] = "3.0" # Use API-Version 3.0 for order placement

    results = []
    order_type_str = "REGULAR"

    for leg in order_input.legs:
        instrument_token = await get_instrument_token(
            order_input.index, leg.strike, order_input.expiry, leg.option_type, access_token
        )
        if not instrument_token:
            raise HTTPException(status_code=404, detail=f"Could not resolve instrument token for {order_input.index} {leg.strike} {leg.option_type} on {order_input.expiry}")

        order_payload = {
            "quantity": leg.quantity,
            "instrument_token": instrument_token,
            "product": "D",  # Assuming 'D' for Delivery/Derivatives for options
            "transaction_type": leg.transaction_type,
            "order_type": leg.order_type,
        }

        if leg.order_type == "LIMIT":
            if leg.price is None:
                raise HTTPException(status_code=400, detail="Price is required for LIMIT orders in each leg.")
            order_payload["price"] = leg.price
        elif leg.price is not None and leg.order_type == "MARKET":
            logger.warning(f"Price provided for MARKET order in leg: {leg.strike} {leg.option_type}. Price will be ignored.")

        if order_input.gtt:
            gtt_url = "https://api-v2.upstox.com/v3/order/gtt/place"
            if leg.order_type == "MARKET":
                raise HTTPException(status_code=400, detail="GTT orders cannot be MARKET orders.")
            if leg.price is None:
                raise HTTPException(status_code=400, detail="Price is required for GTT LIMIT orders in each leg.")
            
            # Simplified GTT rule: single trigger at the provided price
            gtt_order_payload = {
                "instrument_token": order_payload["instrument_token"],
                "quantity": order_payload["quantity"],
                "product": order_payload["product"],
                "transaction_type": order_payload["transaction_type"],
                "order_type": order_payload["order_type"],
                "price": order_payload["price"],
                "rules": [
                    {
                        "strategy": "ENTRY",
                        "trigger_type": "ABOVE" if order_payload["transaction_type"] == "BUY" else "BELOW",
                        "trigger_price": order_payload["price"] # Using price as trigger for simplicity
                    }
                ],
                "type": "SINGLE"
            }
            order_type_str = "GTT"
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.post(gtt_url, json=gtt_order_payload, headers=headers)
                    response.raise_for_status()
                    results.append(response.json())
            except httpx.HTTPStatusError as e:
                logger.error(f"HTTP error placing GTT order for leg {leg.strike} {leg.option_type}: {e.response.status_code} - {e.response.text}")
                raise HTTPException(status_code=e.response.status_code, detail=f"Error placing GTT order: {e.response.text}")
            except httpx.RequestError as e:
                logger.error(f"Network error placing GTT order for leg {leg.strike} {leg.option_type}: {e}")
                raise HTTPException(status_code=500, detail=f"Network error placing GTT order: {str(e)}")
        else:
            regular_order_url = "https://api-v2.upstox.com/v3/order/place"
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.post(regular_order_url, json=order_payload, headers=headers)
                    response.raise_for_status()
                    results.append(response.json())
            except httpx.HTTPStatusError as e:
                logger.error(f"HTTP error placing regular order for leg {leg.strike} {leg.option_type}: {e.response.status_code} - {e.response.text}")
                raise HTTPException(status_code=e.response.status_code, detail=f"Error placing regular order: {e.response.text}")
            except httpx.RequestError as e:
                logger.error(f"Network error placing regular order for leg {leg.strike} {leg.option_type}: {e}")
                raise HTTPException(status_code=500, detail=f"Network error placing regular order: {str(e)}")

    if results:
        # Return a summary or list of results for multi-leg orders
        # For simplicity, returning the first order_id and overall status
        # A more robust response would map each leg to its order_id
        return {
            "status": "success",
            "message": f"Successfully placed {len(results)} orders.",
            "order_ids": [r.get("data", {}).get("order_id") for r in results if r.get("data")],
            "type": order_type_str,
            "details": results # Include full details for debugging/transparency
        }
    return {"status": "error", "message": "No orders were placed."}

@app.get("/ltp", response_model=Dict[str, Any])
async def get_ltp_endpoint(instrument_key: str = Query(..., description="Instrument key (e.g., NSE_FO|NIFTY|2025-07-31|19500CE)")):
    """
    Gets the real-time Last Traded Price (LTP) for a given instrument.
    """
    access_token = await get_upstox_access_token_dep()
    ltp = await get_spot_price_from_upstox(instrument_key, access_token)
    if ltp is None:
        raise HTTPException(status_code=404, detail=f"LTP not found for instrument key: {instrument_key}")
    return {"instrument_key": instrument_key, "ltp": ltp}

@app.get("/option-greeks", response_model=Dict[str, Any])
async def get_option_greeks_endpoint(instrument_key: str = Query(..., description="Instrument key (e.g., NSE_FO|NIFTY|2025-07-31|19500CE)")):
    """
    Gets option Greeks (IV, delta, theta, vega, gamma) for a given instrument key.
    """
    access_token = await get_upstox_access_token_dep()
    greeks = await get_option_greeks_from_upstox(instrument_key, access_token)
    if greeks is None:
        raise HTTPException(status_code=404, detail=f"Option Greeks not found for instrument key: {instrument_key}")
    return greeks

@app.get("/market-timings", response_model=Dict[str, Any])
async def get_market_timings_endpoint(exchange: Optional[str] = Query(None, description="Exchange, e.g., NSE"),
                                     product_type: Optional[str] = Query(None, description="Product type, e.g., EQUITY, FUTURE, OPTION")):
    """
    Gets market timings and holiday information.
    """
    access_token = await get_upstox_access_token_dep()
    timings = await get_market_timings_from_upstox(exchange, product_type, access_token)
    if not timings:
        raise HTTPException(status_code=404, detail="Market timings not found.")
    return timings

@app.get("/order-status", response_model=OrderStatusResponse)
async def get_order_status_endpoint(
    order_id: str = Query(..., description="The ID of the order to check status for."),
):
    """
    Fetches the current status of a specific order from Upstox.
    """
    access_token = await get_upstox_access_token_dep()
    url = "https://api-v2.upstox.com/v2/order/details" # As per openapi.txt get_order_details in v2
    headers = get_upstox_headers(access_token)
    params = {"order_id": order_id} # The API expects order_id as a query parameter

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            response.raise_for_status()
            order_details = response.json()["data"]
            if not order_details:
                raise HTTPException(status_code=404, detail=f"Order with ID {order_id} not found.")
            return order_details
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching order status for {order_id}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error fetching order status: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error fetching order status for {order_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error fetching order status: {str(e)}")

@app.put("/modify-order", response_model=ModifyOrderResponse)
async def modify_order_endpoint(
    modify_input: ModifyOrderInput,
):
    """
    Modifies an existing order (regular or GTT) on Upstox.
    """
    access_token = await get_upstox_access_token_dep()
    headers = get_upstox_headers(access_token)
    headers["Api-Version"] = "3.0" # Ensure V3 for modify

    # Determine if it's a GTT modify based on trigger_price being present
    is_gtt_modify = modify_input.trigger_price is not None

    if is_gtt_modify:
        url = "https://api-v2.upstox.com/v3/order/gtt/modify"
        payload = {
            "gtt_order_id": modify_input.order_id,
            "rules": [
                {
                    "strategy": "ENTRY",
                    "trigger_type": "ABOVE", # This needs to be dynamically determined from original GTT order or inferred
                    "trigger_price": modify_input.trigger_price
                }
            ],
            "type": "SINGLE"
        }
        if modify_input.quantity is not None:
            payload["quantity"] = modify_input.quantity
        if modify_input.price is not None:
            payload["price"] = modify_input.price
    else:
        url = "https://api-v2.upstox.com/v3/order/modify"
        payload = {
            "order_id": modify_input.order_id,
            "quantity": modify_input.quantity,
            "price": modify_input.price,
            "order_type": modify_input.order_type
        }
        # Clean payload from None values
        payload = {k: v for k, v in payload.items() if v is not None}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.put(url, json=payload, headers=headers)
            response.raise_for_status()
            return response.json()
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error modifying order {modify_input.order_id}: {e.response.status_code} - {e.response.text}")
        raise HTTPException(status_code=e.response.status_code, detail=f"Error modifying order: {e.response.text}")
    except httpx.RequestError as e:
        logger.error(f"Network error modifying order {modify_input.order_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Network error modifying order: {str(e)}")

# --- VolGuard Specific Endpoints (Fully functional with Upstox integration) ---

@app.get("/volguard/dashboard", response_model=Dict[str, Any])
async def get_volguard_dashboard(index: str = Query("NIFTY", description="Index for dashboard: NIFTY or SENSEX")):
    """
    Endpoint to provide a comprehensive VolGuard dashboard with combined metrics.
    Integrates data from Upstox (spot price, Greeks) with VolGuard's internal calculations.
    """
    access_token = await get_upstox_access_token_dep()
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")

    config = await get_config(access_token)
    
    nifty_spot_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}{' 50' if index.lower() == 'nifty' else ''}"
    spot_price = await get_spot_price_from_upstox(nifty_spot_key, access_token)
    if spot_price is None:
        raise HTTPException(status_code=404, detail=f"Could not fetch spot price for {index}.")

    # Fetch option chain for the current expiry to determine ATM strike and average IV
    expiries_data = await get_expiries_endpoint(index=index)
    current_expiry_str = expiries_data.get("current_expiry")
    if not current_expiry_str:
        raise HTTPException(status_code=404, detail=f"Could not determine current expiry for {index}.")

    option_chain = await get_option_chain_from_upstox(index, current_expiry_str, access_token)
    
    # Calculate ATM strike and approximate average IV from option chain
    # This is a simplified approach; a more robust one would involve iterating through multiple strikes.
    atm_strike = int(round(spot_price / 100) * 100) # Nearest 100 for ATM
    
    atm_ce_greeks = None
    atm_pe_greeks = None

    if atm_strike in option_chain:
        if option_chain[atm_strike]["CE"]:
            atm_ce_greeks = await get_option_greeks_from_upstox(option_chain[atm_strike]["CE"]["instrument_token"], access_token)
        if option_chain[atm_strike]["PE"]:
            atm_pe_greeks = await get_option_greeks_from_upstox(option_chain[atm_strike]["PE"]["instrument_token"], access_token)
    
    avg_iv = 0.0
    theta_sum = 0.0
    vega_sum = 0.0
    delta_sum = 0.0
    gamma_sum = 0.0
    count_greeks = 0

    if atm_ce_greeks and atm_ce_greeks.get("iv"):
        avg_iv += atm_ce_greeks["iv"]
        theta_sum += atm_ce_greeks.get("theta", 0.0)
        vega_sum += atm_ce_greeks.get("vega", 0.0)
        delta_sum += atm_ce_greeks.get("delta", 0.0)
        gamma_sum += atm_ce_greeks.get("gamma", 0.0)
        count_greeks += 1
    if atm_pe_greeks and atm_pe_greeks.get("iv"):
        avg_iv += atm_pe_greeks["iv"]
        theta_sum += atm_pe_greeks.get("theta", 0.0)
        vega_sum += atm_pe_greeks.get("vega", 0.0)
        delta_sum += atm_pe_greeks.get("delta", 0.0)
        gamma_sum += atm_pe_greeks.get("gamma", 0.0)
        count_greeks += 1
    
    if count_greeks > 0:
        avg_iv /= count_greeks
        theta_avg = theta_sum / count_greeks
        vega_avg = vega_sum / count_greeks
        delta_avg = delta_sum / count_greeks
        gamma_avg = gamma_sum / count_greeks
    else:
        avg_iv, theta_avg, vega_avg, delta_avg, gamma_avg = 0.0, 0.0, 0.0, 0.0, 0.0

    # India VIX is a separate instrument, typically needs its own instrument key or external source
    # Upstox's /market-quote/quotes endpoint could be used if VIX has an instrument key.
    # For now, a placeholder or fetched from a dedicated VIX instrument key.
    # Assuming "NSE_INDEX|INDIA VIX" if available
    vix_instrument_key = "NSE_INDEX|INDIA VIX" # This might vary, confirm actual Upstox VIX key
    india_vix_ltp = await get_spot_price_from_upstox(vix_instrument_key, access_token)
    india_vix = round(india_vix_ltp, 2) if india_vix_ltp else 0.0


    # Calculate straddle price (ATM CE + ATM PE premium)
    straddle_price = 0.0
    if atm_ce_greeks and atm_ce_greeks.get("ltp"):
        straddle_price += atm_ce_greeks["ltp"]
    if atm_pe_greeks and atm_pe_greeks.get("ltp"):
        straddle_price += atm_pe_greeks["ltp"]
    
    # Probability of Profit (POP) is complex and strategy-dependent, here simplified/placeholder
    pop = 0.5 # Placeholder

    # Market metrics data (PCR, Max Pain, Days to Expiry)
    market_metrics_data = await get_market_metrics_data(access_token, index)

    # Calculate volatility metrics (HV, GARCH, IV-RV Spread, IV Percentile)
    realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile = await calculate_volatility(config, avg_iv)

    logger.info("Option Seller Dashboard data compiled successfully.")
    return {
        "spot_price": round(spot_price, 2),
        "india_vix": india_vix,
        "nifty_spot": round(spot_price, 2), # Using same as spot_price for now
        "atm_strike": atm_strike,
        "straddle_price": round(straddle_price, 2),
        "avg_iv": round(avg_iv, 2),
        "theta": round(theta_avg, 2),
        "vega": round(vega_avg, 2),
        "delta": round(delta_avg, 4),
        "gamma": round(gamma_avg, 6),
        "pop": round(pop, 2),
        "pcr": market_metrics_data["pcr"],
        "max_pain": market_metrics_data["max_pain"],
        "days_to_expiry": market_metrics_data["days_to_expiry"],
        "hv_7_day": round(realized_vol_7_day, 2),
        "garch_7_day": round(garch_forecast_7_day, 2),
        "iv_rv_spread": round(iv_rv_spread, 2),
        "iv_percentile": round(iv_percentile, 2)
    }

@app.post("/volguard/strategy-suggestion", response_model=Dict[str, Any])
async def get_strategy_suggestion_endpoint(req: StrategyRequest, index: str = Query("NIFTY", description="Index for strategy suggestion: NIFTY or SENSEX")):
    """
    Provides strategy suggestions based on market conditions.
    This will leverage the existing VolGuard strategy logic, fetching live data.
    """
    access_token = await get_upstox_access_token_dep()
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")

    config = await get_config(access_token)

    # Fetch dynamic inputs for strategy suggestion
    # Get current expiry for 'days_to_expiry'
    expiries_data = await get_expiries_endpoint(index=index)
    current_expiry_str = expiries_data.get("current_expiry")
    if not current_expiry_str:
        raise HTTPException(status_code=404, detail=f"Could not determine current expiry for {index}.")
    
    days_to_expiry = (datetime.strptime(current_expiry_str, "%Y-%m-%d").date() - date.today()).days
    if days_to_expiry < 0: days_to_expiry = 0 # Should not happen with get_expiries_endpoint logic, but for safety

    # Get approximate average IV (could be improved by fetching multiple option Greeks)
    nifty_spot_key = f"{INDEX_TO_INSTRUMENT_PREFIX[index.lower()]}|{INDEX_TO_CONTRACT_SYMBOL[index.lower()]}{' 50' if index.lower() == 'nifty' else ''}"
    spot_price = await get_spot_price_from_upstox(nifty_spot_key, access_token)
    if spot_price is None:
        raise HTTPException(status_code=404, detail=f"Could not fetch spot price for {index} to get approximate IV.")

    atm_strike = int(round(spot_price / 100) * 100)
    
    option_chain = await get_option_chain_from_upstox(index, current_expiry_str, access_token)
    atm_ce_greeks = None
    if atm_strike in option_chain and option_chain[atm_strike]["CE"]:
        atm_ce_greeks = await get_option_greeks_from_upstox(option_chain[atm_strike]["CE"]["instrument_token"], access_token)
    
    avg_iv = atm_ce_greeks.get("iv", 0.0) if atm_ce_greeks else 0.0

    # Calculate IV Percentile (requires historical IV data and current average IV)
    realized_vol_7_day, garch_forecast_7_day, iv_rv_spread, iv_percentile = await calculate_volatility(config, avg_iv)

    # Calculate Regime Score
    regime_score = await calculate_regime_score(access_token, index)

    suggested_strategies = await suggest_strategy(iv_percentile, regime_score, days_to_expiry)
    return {"suggested_strategies": suggested_strategies, "request": req.dict()}

@app.get("/volguard/regime-classification", response_model=Dict[str, float])
async def get_regime_classification_endpoint(index: str = Query("NIFTY", description="Index for regime classification: NIFTY or SENSEX")):
    """
    Returns the multi-factor regime classification score.
    """
    access_token = await get_upstox_access_token_dep()
    if index.upper() not in ["NIFTY", "SENSEX"]:
        raise HTTPException(status_code=400, detail="Invalid index. Must be NIFTY or SENSEX.")
    regime_score = await calculate_regime_score(access_token, index)
    return {"regime_score": round(regime_score, 4)}

@app.post("/volguard/risk-evaluation", response_model=Dict[str, Any])
async def perform_risk_evaluation(req: RiskEvaluationRequest):
    """
    Performs position-level and portfolio-level risk evaluation.
    """
    # This endpoint relies on the active_trades provided in the request body.
    # It does not directly pull live trades from Upstox (which would require fetching positions).
    # If "active_trades" are expected to be fetched live, that would be a separate integration step.
    risk_assessment = await evaluate_risk(req.active_trades)
    return {"risk_assessment": risk_assessment}

@app.get("/volguard/financial-year", response_model=Dict[str, str])
async def get_current_financial_year():
    """
    Returns the current Indian financial year.
    """
    current_date = datetime.now()
    fy = get_financial_year(current_date)
    return {"financial_year": fy}

# WebSocket endpoint for real-time data if needed (example structure)
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    logger.info("WebSocket client connected.")
    try:
        while True:
            # You can send real-time market data or updates here
            # For example, fetch LTP every few seconds and send it
            # This would require a proper Upstox websocket integration
            # The Upstox OpenAPI has a /websocket endpoint, which needs separate implementation
            # using 'websockets' library for client-side connection to Upstox's websocket feed.
            # Example:
            # await websocket.send_json({"message": "Sending dummy real-time data for demonstration"})
            await websockets.sleep(5) # Sleep to avoid busy-waiting, replace with actual data pushing logic
    except WebSocketDisconnect:
        logger.info("WebSocket client disconnected.")
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
